<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java面试八股文 | spikenauy&#39;s blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="Java面试八股文 | spikenauy&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Git 笔记git 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：  &#x2F;etc&#x2F;gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~&#x2F;.gitconfig">
<meta property="og:type" content="article">
<meta property="og:title" content="Git 笔记">
<meta property="og:url" content="http://spikenauy.github.io/2024/07/15/Git-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="spikenauy&#39;s blog">
<meta property="og:description" content="Git 笔记git 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：  &#x2F;etc&#x2F;gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~&#x2F;.gitconfig">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-15T01:57:37.000Z">
<meta property="article:modified_time" content="2024-07-15T01:58:27.751Z">
<meta property="article:author" content="spikenauy">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>spikenauy</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(3)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="-工具">
            
            -工具
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="-面试">
            
            -面试
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="-数据库">
            
            -数据库
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 -面试 "
           href="/2024/09/01/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java面试八股文">Java面试八股文</span>
            <span class="post-date" title="2024-09-01 01:18:12">2024/09/01</span>
        </a>
        
        
        <a  class="全部文章 -数据库 "
           href="/2024/07/15/MySQL%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL笔记">MySQL笔记</span>
            <span class="post-date" title="2024-07-15 10:01:07">2024/07/15</span>
        </a>
        
        
        <a  class="全部文章 -工具 "
           href="/2024/07/15/Git-%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git 笔记">Git 笔记</span>
            <span class="post-date" title="2024-07-15 09:57:37">2024/07/15</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Java面试八股文" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java面试八股文</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="-面试">-面试</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-09-05 10:09:42'>2024-09-01 01:18</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">JAVA面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%88%86%E4%B8%BA%E5%85%AB%E5%A4%A7%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">java基本类型分为八大类型：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说面向对象的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4final%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-text">说说final关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4static%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-text">说说static修饰符的用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">抽象类和接口的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4hashCode-%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E5%B0%B1%E8%A6%81%E9%87%8D%E5%86%99hashCode-%EF%BC%9A"><span class="toc-text">说说hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E9%87%8D%E8%BD%BD%E7%9A%84%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说重载的重写的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%83%BD%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99%EF%BC%9A"><span class="toc-text">说说构造方法能不能重写：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4String%E7%B1%BB-%E4%BB%A5%E5%8F%8Anew%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B4%E6%8E%A5%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说String类,以及new和字符串直接量的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">String、StringBuilder、StringBuffer有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">说说Java的异常处理机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4java%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-text">说说java有哪些异常：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-text">I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4java-IO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">说说java IO流分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4BIO%E3%80%81NIO%E3%80%81AIO%EF%BC%9A"><span class="toc-text">说说BIO、NIO、AIO：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BA%86%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%9F"><span class="toc-text">有了字节流为什么要有字符流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">说说Java中的编码问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4utf-8-%E5%92%8Cutfmb4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说utf-8 和utfmb4的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A"><span class="toc-text">说说序列化、反序列化：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%B3%9B%E5%9E%8B%E3%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9A"><span class="toc-text">说说泛型、类型擦除：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E5%8F%8D%E5%B0%84%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对反射的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9C%A8%E6%A1%86%E6%9E%B6%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">反射在框架工具类中的应用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">JDK 1.8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BJava-8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-text">讲一下Java 8的新特性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">Java并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-text">说说多线程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-text">说说多线程的注意点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">说说线程的创建方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">说说线程的状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4wait%EF%BC%88%EF%BC%89%E5%92%8Csleep%EF%BC%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说wait（）和sleep（）的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A"><span class="toc-text">说说怎么保证线程安全：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">说说你了解的线程同步方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">说说你了解的线程通信方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说Java中常用的锁和原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说synchronized和lock的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4synchronized%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说synchronized的原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9AQS%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说你对AQS的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对线程池的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4volatile%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说volatile的用法和原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9threadlocal%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对threadlocal的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JUC%EF%BC%9A"><span class="toc-text">说说JUC：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E6%9D%A5CAS%EF%BC%9F"><span class="toc-text">java哪些地方用来CAS？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9java%E9%9B%86%E5%90%88%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对java集合的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-text">说说线程安全的集合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说HashMap的底层原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说HashMap和HashTable的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">HashMap是线程安全的吗？如果不是该如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4ConcurrentHashMap%EF%BC%9A"><span class="toc-text">说说ConcurrentHashMap：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9ArrayList%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对ArrayList的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说ArrayList和LinkedList有什么区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说List和Set的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88Null%E5%80%BC%E5%AD%98%E6%94%BE%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">关于各种集合Null值存放问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E4%B8%80%E8%BE%B9%E9%81%8D%E5%8E%86%E4%B8%80%E9%81%8D%E5%88%A0%E9%99%A4%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">List一边遍历一遍删除怎么实现？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">MySQL面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4innodb%E5%92%8Cmyisam%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说innodb和myisam的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="toc-text">如何定位慢查询？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%88%97%EF%BC%9A"><span class="toc-text">如何分析、优化不必要的列：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-text">说说什么是索引：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">说说索引的分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9A"><span class="toc-text">索引的底层数据结构了解吗：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说B树和B+树的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84B-%E6%A0%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">请你说说索引怎么实现的B+树,为什么选这个数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%89%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%EF%BC%9F"><span class="toc-text">什么是聚簇索引什么是非聚簇索引（二级索引）？什么是回表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="toc-text">说说什么是覆盖查询？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">MySQL超大分页怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-text">说说事务的四大特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">并发事务问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A"><span class="toc-text">说说事务的隔离级别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4undo-log%E5%92%8Credo-log%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说undo log和redo log的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9A"><span class="toc-text">MySQL的主从同步是怎么实现的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BMVCC"><span class="toc-text">事务中的隔离性是怎么保证的？解释一下MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-text">了解分库分表吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">请你说说乐观锁和悲观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Spring框架面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSpring"><span class="toc-text">介绍一下Spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9Spring-Boot%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%92%8CSpring%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">说说对Spring Boot的理解，以及和Spring的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Spring-Boot%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说Spring Boot常用的注解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86-Controller"><span class="toc-text">Spring 如何管理 @Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%8D%95%E4%BE%8BBean%E5%92%8C%E5%A4%9A%E4%BE%8BBean%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E9%80%94%EF%BC%9A"><span class="toc-text">说说单例Bean和多例Bean的区别和用途：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E5%8D%95%E4%BE%8Bbean%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E8%BF%99%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%EF%BC%9A"><span class="toc-text">说说对单例bean的理解，这是线程安全的吗？：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Spring-Boot%E7%9A%84%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-text">说说Spring Boot的起步依赖：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Spring-Boot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">说说Spring Boot的启动流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Spring-Boot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说Spring Boot的自动装配原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对IOC的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">IOC的工作流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Bean创建管理方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="toc-text">Bean的生命周期：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说BeanFactory和FactoryBean的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Autowired%E5%92%8C-Resource%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说@Autowired和@Resource注解的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%8C%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">什么是AOP，对AOP的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0AOP%EF%BC%9A"><span class="toc-text">项目中有没有用到AOP：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">说说 JDK 动态代理和 CGLIB 代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9A"><span class="toc-text">Spring中的事务是如何实现的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A"><span class="toc-text">说说Bean的作用域，默认作用域：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9MVC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对MVC的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9Spring-MVC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对Spring MVC的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">说说SpringMVC的执行流程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Redis面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Redis使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%B4%BE%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E7%82%B9"><span class="toc-text">技术派项目面试点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-AOP-TraceID-AOP-TraceID-%E8%AE%B0%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E8%BF%BD%E8%B8%AA%E5%92%8C%E7%9B%91%E6%8E%A7%EF%BC%9A"><span class="toc-text">使用 AOP + TraceID  AOP + TraceID 记录接口访问日志，实现任务追踪和监控：</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="java基本类型分为八大类型："><a href="#java基本类型分为八大类型：" class="headerlink" title="java基本类型分为八大类型："></a>java基本类型分为八大类型：</h3><p>整数类型：byte，short，int，long	浮点类型：float，double</p>
<p>字符类型：char	布尔类型：boolean </p>
<p>byte：1字节 8位	short：2字节 16位	int：4字节 32位	long：8字节 64位	</p>
<p>float：4字节 32位	double：8字节 64位</p>
<p>char：2字节 16位	boolean：不同jvm有不同的实现</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="说说面向对象的理解："><a href="#说说面向对象的理解：" class="headerlink" title="说说面向对象的理解："></a>说说面向对象的理解：</h3><ul>
<li>面向对象包含三大基本特征：封装，继承，多态</li>
<li>封装：将对象的状态信息隐藏在对象内部，外部不能直接访问对象内部信息，使用者通过对象提供的方法堆内部的信息操作和访问，提高了代码的可维护性</li>
<li>继承：是实现代码复用的手段，通过extends实现类的继承，被继承的类叫做父类，实现继承的类叫做子类。</li>
<li>多态：多态的实现离不开继承，在程序中，将参数的数据类型设置为父类，在调用程序的时候，根据情况传入某个子类的实例，这样就实现了多态。程序会根据类型的不同，做出不同的处理反馈</li>
<li>子类可以重写父类的方法，或者实现抽象类或接口的方法</li>
</ul>
<h3 id="说说final关键字："><a href="#说说final关键字：" class="headerlink" title="说说final关键字："></a>说说final关键字：</h3><ul>
<li>final可以用来修饰变量、方法、类</li>
<li>修饰变量的时候，该变量在被初始化后不能被修改，如果是修饰引用类型则引用的地址不能改变但是值可以改变</li>
<li>修饰方法的时候，该方法不能被重写</li>
<li>修饰类的时候，该类不能被继承</li>
</ul>
<h3 id="说说static修饰符的用法："><a href="#说说static修饰符的用法：" class="headerlink" title="说说static修饰符的用法："></a>说说static修饰符的用法：</h3><ul>
<li>static是用来修饰类中的成员变量、方法、代码块、内部类</li>
<li>static修饰的变量属于静态变量，也叫类变量，属于类而不是实例，可以通过类名访问</li>
<li>修饰的方法属于静态方法，一个类中的静态方法不能访问实例变量，只能访问静态变量</li>
<li>静态代码块，可以在类加载的时候执行静态初始化操作</li>
<li>static修饰的内部类，可以访问外部类的静态成员，但是不能访问非静态成员</li>
</ul>
<h3 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h3><ul>
<li>相同点：两者都不能被实例化</li>
<li>抽象类定义的关键字是abstract class，接口的关键字是interface </li>
<li>抽象类可以有静态变量、成员变量、常量，接口只能有常量</li>
<li>抽象方法可以有构造方法和普通方法。但是接口在jdk1.8之前，只能有抽象方法，之后可以有默认方法和静态方法。</li>
<li>一个类只可以继承一个抽象类，但是可以实现多个接口。一个接口也可以继承多个父接口</li>
<li>抽象方法在业务中更像一个模板，有自己的基本功能，同时提供优化补充的方式</li>
<li>接口更像一种规范和要求，定义参数和返回值，要按照接口的规范实现</li>
</ul>
<h3 id="说说hashCode-和equals-的区别-为什么重写equals-就要重写hashCode-："><a href="#说说hashCode-和equals-的区别-为什么重写equals-就要重写hashCode-：" class="headerlink" title="说说hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()："></a>说说hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()：</h3><ul>
<li>hashCode()：获取哈希码，equals()：比较两个对象是否相等。 </li>
<li>二者两个约定：如果两个对象相等,它们必须有相同的哈希码；若两个对象的哈希码相同,他们却不一定相等。也就是说,equals()比较两个对象相等时hashCode()一定相等,hashCode()相等的两个对象equqls()不一定相等。 </li>
<li>加分回答：由于hashCode()与equals()具有联动关系,equals()重写时,hashCode()进行重写,使得这两个方法始终满足相关的约定。</li>
<li>可以关联HashMap说说</li>
</ul>
<h3 id="说说重载的重写的区别："><a href="#说说重载的重写的区别：" class="headerlink" title="说说重载的重写的区别："></a>说说重载的重写的区别：</h3><ul>
<li>重载是发生在同一个类中，重写是发生在子类当中</li>
<li>重载要求方法名相同，但是返回类型，参数，访问修饰符可以不同</li>
<li>重写要求方法名，返回结果，参数都相同，并且子类重写方法的访问修饰符不能大于父类，如果父类的访问修饰符为private，则子类不能重写此方法</li>
</ul>
<h3 id="说说构造方法能不能重写："><a href="#说说构造方法能不能重写：" class="headerlink" title="说说构造方法能不能重写："></a>说说构造方法能不能重写：</h3><ul>
<li>构造方法在一个类中可以有多个，多个构造器的形参列表不同，可以称作构造器重载，让java类包含了多个初始化逻辑。</li>
<li>构造方法不能被重写，因为重写要求子类和父类的方法名一样，但是不同类的类名是不同的，构造方法是需要和类同名，所以不能重写。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="说说String类-以及new和字符串直接量的区别："><a href="#说说String类-以及new和字符串直接量的区别：" class="headerlink" title="说说String类,以及new和字符串直接量的区别："></a>说说String类,以及new和字符串直接量的区别：</h3><ul>
<li>String类是java常用的API，其中有很多封装好的处理字符串的方法，比如charAt 查找索引处的字符、indexOf查询字符首次出现的位置、subString截取字符串等方法</li>
<li>String的特点有不可变性，一旦被创建其内容就无法被更改，然后对字符串的修改都会产生一个新的String对象</li>
<li>String是被final修饰的，不能被继承</li>
<li>创建字符串有两种方式：用字符串常量创建的时候，JVM会检查字符串池中是否存在相同内容的字符串，如果有则返回这个字符串的引用</li>
<li>如果使用new来创建字符串，则不会去检查字符串池，直接在堆内存创建新的String对象</li>
</ul>
<h3 id="String、StringBuilder、StringBuffer有什么区别？"><a href="#String、StringBuilder、StringBuffer有什么区别？" class="headerlink" title="String、StringBuilder、StringBuffer有什么区别？"></a>String、StringBuilder、StringBuffer有什么区别？</h3><ul>
<li>String类是不可变的，一旦创建字符串内容不能修改，所有修改的字符串会创建为新的字符串对象，这使得String在多线程的环境下是安全的</li>
<li>StringBuilder类，可变字符序列，操作不被synchronized修饰，性能优于StringBuffer，但是线程不安全</li>
<li>StringBuffer类，也是可变字符串序列，修改字符串不会创建新的对象，操作中使用了同步机制，加了锁，性能不如StringBuilder</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="说说Java的异常处理机制："><a href="#说说Java的异常处理机制：" class="headerlink" title="说说Java的异常处理机制："></a>说说Java的异常处理机制：</h3><ul>
<li>异常机制让程序具有容错性和健壮性，程序允许出现错误时，系统会生成一个Exception对象来通知程序</li>
<li>处理异常的语句由 try，catch，finally 组成，try用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally则是用于回收资源，是最后会执行的代码</li>
<li>如果程序出现异常，系统会创建一个异常类，提交给JVM，JVM寻找可以处理这个异常的catch块，交给这个块来处理，当JVM没有找到的时候，允许环境终止，java程序退出</li>
<li>java也允许程序主动抛出异常，当业务中用判断符合某项错误的条件成立的时候，可以用throw关键字向外抛出异常</li>
</ul>
<h3 id="说说java有哪些异常："><a href="#说说java有哪些异常：" class="headerlink" title="说说java有哪些异常："></a>说说java有哪些异常：</h3><ul>
<li>主要分为受检异常Checked Exception和非受检异常Unchecked Exception，还有严重错误Error</li>
<li>Checked Exception 受检异常是表示程序允许时可能遇到的异常，需要通过try catch显式处理，通常表示外部环境的问题，比如：IOExpection、SQLException、ClassNotFoundException</li>
<li>非受检异常，也叫runtimeException，是程序逻辑错误引起的，比如：NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException</li>
<li>Error严重错误，这些错误不需要捕获和处理，比如：OutOfMemoryError，StackoverflowError</li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="说说java-IO流分为几种？"><a href="#说说java-IO流分为几种？" class="headerlink" title="说说java IO流分为几种？"></a>说说java IO流分为几种？</h3><ul>
<li>Java IO是Java提供处理数据输入和输出的API</li>
<li>根据数据流方向：<ul>
<li>输入流 Input Stream、Writer：从源 比如文件、网络中读取到程序</li>
<li>输出流 Output Stream、Reader：将数据从程序中写出到外部文件，比如文件、网络、控制台</li>
<li>以上分别是用于读取 和写入的抽象类，其他的具体流类都是它们的实现类</li>
</ul>
</li>
<li>根据处理数据单位：<ul>
<li>字节流 Byte Streams：以字节为单位读写数据，主要用于处理二进制数据，比如音频、图像文件等 ：Input Stream、Output Stream</li>
<li>字符流 Character Streams：以字符为单位读写数据，主要处理文本数据：Writer、Reader</li>
</ul>
</li>
<li>在 Java I&#x2F;O 中，<code>FileInputStream</code>、<code>ByteArrayInputStream</code>、<code>BufferedInputStream</code> 是字节流，用于处理二进制数据。</li>
<li><code>FileInputStream</code> 用于从文件中读取字节数据，<code>ByteArrayInputStream</code> 从内存中的字节数组读取数据，而 <code>BufferedInputStream</code> 提供缓冲功能以提高读取效率。</li>
<li>字符流包括 <code>FileReader</code>、<code>BufferedReader</code>、<code>InputStreamReader</code>，其中 <code>FileReader</code> 用于读取文本文件，<code>BufferedReader</code> 增加了按行读取的功能并提供缓冲，而 <code>InputStreamReader</code> 则将字节流转换为字符流，用于处理带有字符编码的数据源。</li>
</ul>
<p>完整回答：</p>
<p>“Java IO是Java中用于处理数据输入和输出的API。根据数据流的方向，Java IO分为输入流和输出流。输入流（如<code>InputStream</code>和<code>Reader</code>）用于从外部源读取数据到程序中，而输出流（如<code>OutputStream</code>和<code>Writer</code>）则将数据从程序写出到外部目标。</p>
<p>按处理的数据单位，Java IO分为字节流和字符流。字节流以字节为单位读写数据，主要用于处理二进制数据，比如音频或图像文件。<code>InputStream</code>和<code>OutputStream</code>是字节流的抽象类，常见的具体实现包括<code>FileInputStream</code>用于从文件中读取字节数据，<code>ByteArrayInputStream</code>用于从内存中的字节数组读取数据，而<code>BufferedInputStream</code>提供缓冲功能以提高读取效率。</p>
<p>字符流则以字符为单位读写数据，主要用于处理文本。<code>Reader</code>和<code>Writer</code>是字符流的抽象类，具体实现包括<code>FileReader</code>用于读取文本文件，<code>BufferedReader</code>增加了按行读取的功能并提供缓冲，而<code>InputStreamReader</code>则将字节流转换为字符流，便于处理带有字符编码的数据源。”</p>
<h3 id="说说BIO、NIO、AIO："><a href="#说说BIO、NIO、AIO：" class="headerlink" title="说说BIO、NIO、AIO："></a>说说BIO、NIO、AIO：</h3><ul>
<li>BIO是blocking IO，是传统的Java I&#x2F;O操作系统，基于阻塞I&#x2F;O实现。每个请求都有一个独立的线程来处理，线程会阻塞等待数据读写操作完成，简单易用，高并发下性能较差</li>
<li>NIO是非阻塞IO，用户线程发送请求后，可以做其他工作，并且通过轮询的方式不断询问内核数据，但在数据复制阶段，用户线程仍然数据阻塞状态。适合高并发环境</li>
<li>BIO和NIO都属于同步IO</li>
<li>AIO是异步IO模式，用户线程发送请求后，内核会返回一个回调函数，不包含数据，之后用户线程可以处理其他操作，当数据准备好后，内核会将数据发送给用户线程，不必向同步IO中用户线程自己去读取</li>
<li>BIO只能处理一个请求，NIO可以处理多个请求，</li>
</ul>
<h3 id="有了字节流为什么要有字符流？"><a href="#有了字节流为什么要有字符流？" class="headerlink" title="有了字节流为什么要有字符流？"></a>有了字节流为什么要有字符流？</h3><ul>
<li>字符流是JVM将字节转换得到的，这个转换过程耗时，而且不知道编码类型容易出现乱码问题</li>
<li>所以IO直接提供一个操作字符的接口，自动处理字符编码和解码，字符流支持字符集编码转换，可以增强处理多语言字符</li>
</ul>
<h3 id="说说Java中的编码问题："><a href="#说说Java中的编码问题：" class="headerlink" title="说说Java中的编码问题："></a>说说Java中的编码问题：</h3><ul>
<li>Java中常见的字符编码有iso、utf-8、gbk</li>
<li>iso是一种单字节编码，适用于英文等西欧语言，如果这个编码格式显示中文会乱码</li>
<li>utf-8是一种可变长度字符编码，用于表示Unicode字符集，兼容ASCII，可以表示世界上几乎所有的语言，</li>
<li>GBK在处理中文字符更加高效，如果是一下旧版中文系统，可以使用这个</li>
</ul>
<h3 id="说说utf-8-和utfmb4的区别："><a href="#说说utf-8-和utfmb4的区别：" class="headerlink" title="说说utf-8 和utfmb4的区别："></a>说说utf-8 和utfmb4的区别：</h3><ul>
<li>UTF-8和UTF-8MB4的主要区别在于编码范围和存储能力</li>
<li>UTF-8最多使用3个字节存储一个字符，适用于大部分普通文本</li>
<li>UTF-8MB4最多使用4个字节，能够存储所有的Unicode字符，包括表情符号和特殊符号。</li>
<li>对于需要存储表情符号或扩展字符的应用场景，UTF-8MB4是更好的选择。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="说说序列化、反序列化："><a href="#说说序列化、反序列化：" class="headerlink" title="说说序列化、反序列化："></a>说说序列化、反序列化：</h3><ul>
<li>序列化是将对象转换为字节流的过程，可以将对象存储或传输到文件或者通过网络传输</li>
<li>反序列化是将字节流还原为对象的过程</li>
<li>再Java中通过实现Serializable接口启用对象的序列化</li>
<li>通过ObjectOutputStream将对象写入到文件或其他输入流中</li>
<li>通过ObjectInputStream从文件中读取输入流读取对象，将字节流转换为对象（用强制转换 读取objectInputStream.readstream()）</li>
<li>Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来进行一些操作，比如将对象转化为 byte 数组或者将 json 串转化为对象。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="说说泛型、类型擦除："><a href="#说说泛型、类型擦除：" class="headerlink" title="说说泛型、类型擦除："></a>说说泛型、类型擦除：</h3><ul>
<li>在JDK1.5中，引入了泛型，在没有泛型之前，每次从集合中读取对象都必须进行类型转换，如果在插入对象时，类型出错，那么运行时转换处理的阶段就出错</li>
<li>在引入泛型之后，可以明确指定集合接受哪些对象类型，编译器就能知道并且自动为插入的代码进行泛化，在编译阶段如果插入类型错误的对象就会报错</li>
<li>泛型擦除，java泛型时伪泛型，因为java代码在编译阶段，所有的泛型信息都会被擦除，生成的字节码文件是不包含泛型信息的</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="说说对反射的理解："><a href="#说说对反射的理解：" class="headerlink" title="说说对反射的理解："></a>说说对反射的理解：</h3><ul>
<li>反射是在程序运行的时候动态的获取对象的属性和方法的功能叫做反射。它能够在程序运行期间，对于任意一个类都能知道它的所有方法和属性。</li>
<li>可以在不知道类具体实现的情况下创建类实例、调用方法、访问属性。</li>
<li>反射在框架、工具类库等方面由广泛的应用</li>
</ul>
<h3 id="反射在框架工具类中的应用场景："><a href="#反射在框架工具类中的应用场景：" class="headerlink" title="反射在框架工具类中的应用场景："></a>反射在框架工具类中的应用场景：</h3><ul>
<li>Spring框架中的依赖注入，通过反射，Spring容器可以在运行的时候，动态的实例化Bean，并将其注入到其他Bean中。Spring通过扫描类路径获取注解，比如：@AutoWired、@Component，然后通过反射创建对象、设置属性、调用方法</li>
<li>使用JDBC时，如果要创建数据库的连接，需要先通过反射机制，加载数据库的驱动程序</li>
<li>面向切面编程AOP的实现方案，是在程序运行时创建目标对象的代理类</li>
</ul>
<h2 id="JDK-1-8新特性"><a href="#JDK-1-8新特性" class="headerlink" title="JDK 1.8新特性"></a>JDK 1.8新特性</h2><h3 id="讲一下Java-8的新特性："><a href="#讲一下Java-8的新特性：" class="headerlink" title="讲一下Java 8的新特性："></a>讲一下Java 8的新特性：</h3><p><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。   </p>
<p>​    <strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。   </p>
<p>​    <strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。   </p>
<p>​    <strong>新工具</strong> − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。   </p>
<p>​    <strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。   </p>
<p>​    <strong>Date Time API</strong> − 加强对日期与时间的处理。   </p>
<p>​    <strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。   </p>
<p>​    <strong>Nashorn, JavaScript 引擎</strong> − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p>
<h2 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h2><h3 id="说说多线程："><a href="#说说多线程：" class="headerlink" title="说说多线程："></a>说说多线程：</h3><ul>
<li>线程是操作系统调度的最小单元，它可以让进程并发的处理多个任务</li>
<li>一个进程可以创建多个线程，各个线程共享程序的内存空间，比如代码段，多个线程可以执行相同的代码；</li>
<li>共享数据段，多个线程可以访问或修改相同的全局变量或静态变量；</li>
<li>共享堆空间，堆是动态分配内存的区域，通常分配对象的内存，多个线程可以创建、访问和修改堆中的对象；</li>
<li>每个线程拥有自己的栈空间</li>
<li>多线程的优点：减少程序响应时间，提高cpu利用率，数据共享效率高</li>
</ul>
<h3 id="说说多线程的注意点："><a href="#说说多线程的注意点：" class="headerlink" title="说说多线程的注意点："></a>说说多线程的注意点：</h3><ul>
<li>线程安全方面，多个线程同时访问共享资源时，可能导致数据不一致。可以使用synchronized或lock加锁来确保线程安全</li>
<li>频繁创建和销毁线程会浪费系统资源，使用线程池来管理线程可以重用线程，减少线程的开销</li>
</ul>
<h3 id="说说线程的创建方式："><a href="#说说线程的创建方式：" class="headerlink" title="说说线程的创建方式："></a>说说线程的创建方式：</h3><ul>
<li>创建线程有三种方式：继承thread类、实现Runable接口、实现Callable接口</li>
<li>定义Thread类的子类，重写run方法，创建这个子类的实例，调用线程对象的start（）方法来启动这个线程</li>
<li>实现Runable接口，实现接口的run（）方法，创建实现类的实例，将其作为参数来创建Thread对象，调用start（）方法来启动线程</li>
<li>实现Callable接口，重写call方法，call方法为线程的执行体，创建Callable实现类的实例，以该实例为参数，创建FutureTask对象。使用FutureTask对象作为参数，创建Thread对象启动线程，调用FutureTask对象的get（）方法，获得子线程结束的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running using Thread class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running using Runnable interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Thread result from Callable.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); <span class="comment">// 获取返回结果</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建线程分为两种：继承父类、实现接口</li>
<li>实现Runable接口和Callable接口创建线程的区别是：Runable没有返回值。但是Callable有返回值</li>
<li>采用接口方式创建线程的优点是：线程类可以继承别的其他类。</li>
<li>如果采用继承Thread类，就不可以继承其他的父类</li>
</ul>
<h3 id="说说线程的状态："><a href="#说说线程的状态：" class="headerlink" title="说说线程的状态："></a>说说线程的状态：</h3><ul>
<li>java线程在运行的生命周期中，有六个状态：</li>
<li>NEW：初始状态，线程被创建，但是没有调用start方法</li>
<li>RUNABLE：可运行状态，线程正在JVM执行，可能是等待操作系统的调度</li>
<li>BLOCKED：阻塞状态，线程正在等待获取监视器锁，当一个线程试图进入一个 <code>synchronized</code> 方法或代码块，而此时该对象的监视器锁已经被其他线程占用，这个线程就会进入阻塞状态，等待监视器锁的释放。</li>
<li>WATING：等待状态，线程正在等待其他线程的的操作来继续执行，当一个线程调用某个对象的 <code>wait()</code> 方法时，线程会释放该对象的监视器锁，并进入 WAITING 状态，直到另一个线程调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法来唤醒它。</li>
<li>TIMED_WATING：超时等待状态，在等待状态的基础上增加了超时时间，即超出时间自动返回。</li>
<li>TERMINATED：终止状态，线程已经执行完毕</li>
</ul>
<h3 id="说说wait（）和sleep（）的区别："><a href="#说说wait（）和sleep（）的区别：" class="headerlink" title="说说wait（）和sleep（）的区别："></a>说说wait（）和sleep（）的区别：</h3><ul>
<li>wait是object类的方法，而sleep是Thread类的方法</li>
<li>wait（）调用的时候会释放当前线程的锁，其他线程可以进入同步代码块或方法，而sleep（）不会释放锁，线程只是暂停执行，但是仍然持有锁</li>
<li>wait（）通常在同步块或方法中使用，目的是让当前线程等待，直到其他线程调用notify（）或notify All（）</li>
<li>sleep（）只是让线程休眠一段时间，不涉及锁和同步</li>
</ul>
<h3 id="说说怎么保证线程安全："><a href="#说说怎么保证线程安全：" class="headerlink" title="说说怎么保证线程安全："></a>说说怎么保证线程安全：</h3><ul>
<li><p>线程安全是在多线程中，线程没有按照预期执行，导致操作共享变量出现异常。在java中有多种同步方案可以使用：原子类、volatile关键字、锁</p>
</li>
<li><p>原子类：基于底层CAS，比较和替换机制，比较要更新的值是否等于预期值。<code>AtomicInteger</code>、<code>AtomicReference</code>，通过原子操作确保线程安全，避免锁的开销。</p>
</li>
<li><p>volatile关键字：适用于确保变量的可见性，但它不保证操作的原子性</p>
</li>
<li><p>使用synchronized关键字，可以在方法或代码块上使用，确保同一时间只有一个线程可以访问                 </p>
</li>
<li><p>使用Lock锁：通过lock、unlock方法所住一段代码</p>
</li>
</ul>
<h3 id="说说你了解的线程同步方式："><a href="#说说你了解的线程同步方式：" class="headerlink" title="说说你了解的线程同步方式："></a>说说你了解的线程同步方式：</h3><ul>
<li>java主要通过加锁的方式实现线程同步，锁分为两种：synchronized和Lock</li>
<li>synchronized可以加在三个位置：</li>
<li>加在普通方法上的时候，锁的是这个方法的实例对象；加在静态方法上，锁的是当前类的对象；加在代码块上时，要在synchronized后显式指定一个对象，当一个线程要进入这个代码块，必须要先获得这个对象的锁 </li>
<li>synchronized是比较早期的API，没有超时等机制</li>
<li>Lock支持的功能包括：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）</li>
</ul>
<h3 id="说说你了解的线程通信方式："><a href="#说说你了解的线程通信方式：" class="headerlink" title="说说你了解的线程通信方式："></a>说说你了解的线程通信方式：</h3><ul>
<li>包括使用wait&#x2F;notify进行简单的同步，Lock和Condition提供更灵活的控制，</li>
<li>ThreadLocal为线程提供独立的变量存储</li>
</ul>
<h3 id="说说Java中常用的锁和原理："><a href="#说说Java中常用的锁和原理：" class="headerlink" title="说说Java中常用的锁和原理："></a>说说Java中常用的锁和原理：</h3><ul>
<li>synchronized关键字和lock锁接口：</li>
<li>synchronized关键字底层用的是java对象头来存储锁信息</li>
<li>lock接口是基于AQS实现，AQS内部是一个先进先出队列实现锁的同步，同时定义了同步状态记录锁的信息</li>
</ul>
<h3 id="说说synchronized和lock的区别："><a href="#说说synchronized和lock的区别：" class="headerlink" title="说说synchronized和lock的区别："></a>说说synchronized和lock的区别：</h3><ul>
<li>synchronized是同步锁，可以修饰普通方法、静态方法、代码块</li>
<li>修饰普通方法，锁住的是实例对象；修饰静态方法时，锁住的是类对象；修饰代码块的时候，是要指定一个对象，然后锁住</li>
<li>当一个线程在使用被锁住的方法时，获取了它的锁，其他线程想要访问当前资源只能等待当前锁释放锁</li>
<li>synchronized是java的关键字，lock是接口</li>
<li>synchronized可以作用在代码块和方法上，lock只能用在代码里</li>
<li>synchronized在代码执行完毕或出现异常会自动释放锁，但是lock不会自动释放，需要在finally中释放</li>
<li>synchronized会导致线程拿不到锁一直等待，死锁。但是lock可以设置超时时间，如果在指定时间内无法获取锁，线程可以选择退出或执行其他操作</li>
<li>synchronized无法知道是否获取锁成功，但是lock可以通过tryLock判断是否加锁成功</li>
</ul>
<h3 id="说说synchronized的原理："><a href="#说说synchronized的原理：" class="headerlink" title="说说synchronized的原理："></a>说说synchronized的原理：</h3><ul>
<li>原理是通过JVM在编译生成的 monitorenter 和 monitorexit 指令来实现</li>
<li>这些指令利用Java对象头中的锁信息来管理锁的获取和释放</li>
<li>当线程进入或者退出同步代码块的时候，会自动获取和释放对象的监视器锁，从而实现线程的同步控制</li>
</ul>
<h3 id="说说你对AQS的理解："><a href="#说说你对AQS的理解：" class="headerlink" title="说说你对AQS的理解："></a>说说你对AQS的理解：</h3><ul>
<li>AQS队列同步器，用来构建锁的基本框架，Lock实现类都是基于AQS实现的</li>
<li>AQS是基于模板方法模式进行设计的，锁的实现需要继承AQS并重写指定的方法</li>
<li>AQS内部定义了一个先进先出的队列来实现线程的同步，同时还定义了同步状态来记录锁的信息</li>
</ul>
<h3 id="说说对线程池的理解："><a href="#说说对线程池的理解：" class="headerlink" title="说说对线程池的理解："></a>说说对线程池的理解：</h3><ul>
<li>线程池可以管理线程的数量，减少无节制的创建线程导致超出系统负荷。</li>
<li>可以让线程复用，大大减少创建和销毁线程所带来的开销</li>
<li>线程池管理了多个线程的生命周期，提供了任务的提交和调度机制，减少线程上下文切换的开销</li>
<li>线程池的生命周期分为五种：</li>
<li>RUNING -1：线程可以接受新任务并处理队列中的任务</li>
<li>SHUTDOWN 0：线程池不再接收新的任务，但是会继续处理队列中的任务</li>
<li>STOP 1：线程不在接受新的任务，也不再处理队列中的任务，并中断正在执行的任务</li>
<li>TIDYING 2：所有任务都终止，线程池工作的线程数都为0，即将调用terminated（）方法</li>
<li>TEMINATED 3：teminated（）方法调用完毕，线程池完全终止</li>
</ul>
<h3 id="说说volatile的用法和原理："><a href="#说说volatile的用法和原理：" class="headerlink" title="说说volatile的用法和原理："></a>说说volatile的用法和原理：</h3><ul>
<li>volatile是一个轻量级的synchronized，它可以在多线程中确保共享变量的可见性。保证一个线程修改一个共享变量的时候，另外一个线程可以读取整个修改的值</li>
<li>底层原理是通过内存屏障（Memory Barrier）来实现的，读写 <code>volatile</code> 变量时会在指令前后插入内存屏障，确保变量的可见性和有序性，但不保证原子性。常用于避免多线程中变量不一致问题，如双重检查锁定的单例模式中。</li>
</ul>
<h3 id="说说对threadlocal的理解："><a href="#说说对threadlocal的理解：" class="headerlink" title="说说对threadlocal的理解："></a>说说对threadlocal的理解：</h3><ul>
<li>ThreadLocal，线程变量，是一种为每个线程提供独立的变量副本，确保每个线程对变量的访问互不打扰，避免线程之间共享数据问题，也叫不需要同步机制了</li>
<li>提供线程变量，可以存储线程私有的状态和上下文信息，比如用户会话</li>
<li>实现原理：每个Thread对象中都有一个ThreadLocalMap对象，他是一个键值对形式的容器，可以用set、get方法存取共享变量。</li>
<li>ThreadLocal对象作为key来存取共享变量，用完之后必须remove，否则会造成内存泄漏</li>
<li>在线程池中，线程不会在任务结束后立即销毁，而是重用。若 <code>ThreadLocal</code> 未被清除，它对应的值可能无法释放，累积后导致内存泄漏。</li>
</ul>
<h3 id="说说JUC："><a href="#说说JUC：" class="headerlink" title="说说JUC："></a>说说JUC：</h3><ul>
<li>JUC是java.util.concurrent的缩写，这个包中包含了支持并发操作的各种工具：</li>
<li>原子类：底层使用CAS机制实现原子性，原子类包括：AtomicInteager 支持对int类型变量的原子操作、AtomicBoolean、AtomicLong、AtomicReference 支持对引用类型变量进行原子操作</li>
<li>Lock锁类：和synchroized类似，在此基础上增加了超时机制，响应中断机制，用于解决多线程安全问题</li>
<li>线程池：可以方便的管理线程，避免重复开线程和杀线程的消耗</li>
<li>并发容器：比如ConcurrentHashMap、CopyOnWriteArrayList，支持多线程操作的并发集合</li>
</ul>
<h3 id="java哪些地方用来CAS？"><a href="#java哪些地方用来CAS？" class="headerlink" title="java哪些地方用来CAS？"></a>java哪些地方用来CAS？</h3><ul>
<li>CAS是比较和交换的意思，使用场景有原子类、AQS、并发容器</li>
<li>实现类原子类 atomicInteager…、并发容器集合 ConcurrentHashMap、Lock的底层实现是AQS，AQS的实现是通过一个volatile的状态变量和CAS操作控制线程的访问权限保证原子性</li>
</ul>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="说说对java集合的理解："><a href="#说说对java集合的理解：" class="headerlink" title="说说对java集合的理解："></a>说说对java集合的理解：</h3><ul>
<li>java集合类主要分为两类：Collection和Map这两个接口派生而出，其中Collection接口派生出 List、Set、Queue</li>
<li>Set 中元素无序存储、元素不可重复</li>
<li>List 是有序存储，顺序为存储顺序，元素可以重复</li>
<li>Queue 是先进先出队列</li>
<li>Map 是存放键值对的 代表映射关系的集合</li>
<li>这些集合的实现类有ArrayList、LinkedList、TreeSet、HashSet、HashMap等，这些实现类都不是线程安全，但是性能好</li>
<li>线程安全的集合实现类有：Vector、HashTable、ConcurrentHashMap</li>
<li>Vector实现了List接口，是一个动态数组，所有方法都是同步的，使用了synchronized实现</li>
<li>HashTable 实现了Map接口，是基于hash表的数据结构，用于存储键值对，不允许有null键和值，所有方法也是同步的，因此是线程安全的，但是性能不好</li>
<li>HashTable、ConcurrentHashMap、TreeMap、TreeMap、EnumMap、EnumSet 不允许有null出现</li>
</ul>
<h3 id="说说线程安全的集合："><a href="#说说线程安全的集合：" class="headerlink" title="说说线程安全的集合："></a>说说线程安全的集合：</h3><ul>
<li>线程安全的集合有Vector 实现List接口，底层是动态数组、HashTable 实现Map类，底层是哈希表实现</li>
<li>利用Collection工具类，提供了synchronizedList&#x2F;Set等方法，将集合类包装从线程安全的集合类</li>
<li>使用JUC包下的并发容器，比如ConcurrentHashMap、ConcurrentLinkedQueue</li>
<li>使用写时复制的批发容器，比如 CopyOnWirteArrayList &#x2F; Set，读写时会创建一个新的副本在这个上面修改、不会受到写操作的影响</li>
</ul>
<h3 id="说说HashMap的底层原理："><a href="#说说HashMap的底层原理：" class="headerlink" title="说说HashMap的底层原理："></a>说说HashMap的底层原理：</h3><ul>
<li>再JDK1.8之前HahMap的底层是数组加链表、再1.8之后是数组加链表加红黑树</li>
<li>put流程是 根据哈希算法确定元素的下标位置，当向集合存入数据时，会计算传入key的hash值，通过将哈希值取绝对值再根据集合长度取余来确定元素位置</li>
<li>如果这个位置存在其他元素，则发生哈希冲突，这个新的元素会被存在当前位置的链表中，如果链表的长度超过8，就会转化为红黑树。</li>
<li>Hash不是线程安全</li>
</ul>
<h3 id="说说HashMap和HashTable的区别："><a href="#说说HashMap和HashTable的区别：" class="headerlink" title="说说HashMap和HashTable的区别："></a>说说HashMap和HashTable的区别：</h3><ul>
<li>区别在于是否线程安全，是否可以存放null值</li>
<li>Hashtable再实现Map接口的时候包装了线程安全，加入了同步机制</li>
<li>HashMap是非线程安全，所有HashTable的性能不如HashMap</li>
<li>HashTable不允许存入null，无论是key还是Value，都会异常</li>
<li>HashMap可以存放null，都可以</li>
<li>多线程下推荐使用ConcurrentHashMap，它不但保证了线程安全，也降低了锁的颗粒度，提高了并发访问的性能</li>
</ul>
<h3 id="HashMap是线程安全的吗？如果不是该如何解决？"><a href="#HashMap是线程安全的吗？如果不是该如何解决？" class="headerlink" title="HashMap是线程安全的吗？如果不是该如何解决？"></a>HashMap是线程安全的吗？如果不是该如何解决？</h3><ul>
<li>使用Hashtable、使用Collections将HashMap包装成线程安全的HashMap、使用ConcurrentHashMap,</li>
</ul>
<h3 id="说说ConcurrentHashMap："><a href="#说说ConcurrentHashMap：" class="headerlink" title="说说ConcurrentHashMap："></a>说说ConcurrentHashMap：</h3><ul>
<li>ConcurrentHashMap的底层数据结构与HashMap一样,也是采用“数组+链表+红黑树 </li>
<li>采用锁定头节点的方式降低了锁粒度,以较低的性能代价实现了线程安全。</li>
<li>实现机制：初始化数组或头节点时,ConcurrentHashMap并没有加锁,而是CAS的方式进行原子替换 </li>
<li>插入数据时会进行加锁处理,但锁定的不是整个数组,而是槽中的头节点。所以,ConcurrentHashMap中锁的粒度是槽,而不是整个数组,并发的性能很好。 </li>
<li>扩容时会进行加锁处理,锁定的仍然是头节点。并且,支持多个线程同时对数组扩容,提高并发能力。 </li>
<li>在扩容的过程中,依然可以支持查找操作。</li>
</ul>
<h3 id="说说对ArrayList的理解："><a href="#说说对ArrayList的理解：" class="headerlink" title="说说对ArrayList的理解："></a>说说对ArrayList的理解：</h3><ul>
<li>ArrayList是基于数组实现的，内部封装了一个Object[] 数组</li>
<li>通过默认构造器创建的时候，先被初始化为空数组，之后在首次添加数据的时候，将其初始化为容量为10的数组</li>
<li>也可以通过有参构造函数创建容器，通过参数显式指定数组的容量，数组会被初始化为指定容量的数组</li>
<li>如果向ArrayList数组中添加数据超出长度限制，会自动触发自动扩容，然后添加数据</li>
<li>扩容计算数组拷贝，将旧数组的数据拷贝到新数组中，新数组的长度为原来的1.5倍</li>
<li>支持缩容，但是不会自动缩容，可以调用trimToSize（）方法</li>
<li>ArrayList是有序可重复集合，提供了iterator方法</li>
</ul>
<h3 id="说说ArrayList和LinkedList有什么区别："><a href="#说说ArrayList和LinkedList有什么区别：" class="headerlink" title="说说ArrayList和LinkedList有什么区别："></a>说说ArrayList和LinkedList有什么区别：</h3><ul>
<li>ArrayList的实现是基于数组的，LinkedList的实现是基于双向链表</li>
<li>对于随机访问集合元素，ArrayList要优于Linked，ArrayList可以根据下标以复杂度为1对元素进行随机访问，而LinkedList的每个元素要都是依赖地址指针和下一个元素连接，所以查找的复杂度为N</li>
<li>对于插入和删除的操作，LinkedList要优于ArrayList，因为当元素被添加到Linked任意位置，只需要调节节点的前后引用，但是ArrayList插入操作可能要移动大量元素</li>
<li>LinkedList比Array更占内存，因为除了存储数据，还存储了两个前后引用</li>
</ul>
<h3 id="说说List和Set的区别："><a href="#说说List和Set的区别：" class="headerlink" title="说说List和Set的区别："></a>说说List和Set的区别：</h3><ul>
<li>List集合是有序存储的，可以存储重复的元素，集合内每个元素都有对应的顺序索引，默认是按照插入顺序设置索引</li>
<li>Set集合中的元素是无序存储的，不能存储重复元素，不允许包含相同的元素，会失败，add方法会返回False</li>
<li>Set虽然无序，但是也有支持排序的集合：TreeSet，TreeSet可以确保元素处于排序状态，底层是红黑树实现，如果元素实现了Comparable接口，TreeSet会使用接口的compareTo（）方法来确定元素顺序，如果在创建TreeSet的时候在参数中提供一个Comparator，TreeSet会使用这个定制排序来确定元素顺序，TreeSet内部元素不能为Null值</li>
</ul>
<h3 id="关于各种集合Null值存放问题："><a href="#关于各种集合Null值存放问题：" class="headerlink" title="关于各种集合Null值存放问题："></a>关于各种集合Null值存放问题：</h3><ul>
<li><strong>数组和链表实现的集合</strong> 通常直接存储对象，因此能够存放 <code>null</code>。</li>
<li><strong>哈希表实现的集合</strong> 允许 <code>null</code>，但通常 <code>null</code> 键只能有一个，因为哈希表使用键的哈希码来定位元素，而 <code>null</code> 键是一个特殊情况。</li>
<li><strong>红黑树和其他需要比较操作的集合</strong> 不允许 <code>null</code>，因为 <code>null</code> 无法参与元素比较。</li>
<li><strong>线程安全集合</strong> 通常为了避免 <code>null</code> 引发的潜在并发问题，选择不支持 <code>null</code>。</li>
</ul>
<h3 id="List一边遍历一遍删除怎么实现？"><a href="#List一边遍历一遍删除怎么实现？" class="headerlink" title="List一边遍历一遍删除怎么实现？"></a>List一边遍历一遍删除怎么实现？</h3><ul>
<li><p>使用Iterator提供的remove方法</p>
</li>
<li><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));
Iterator&lt;String&gt; iterator = list.iterator();

while (iterator.hasNext()) &#123;
    String element = iterator.next();
    if (&quot;b&quot;.equals(element)) &#123;
        iterator.remove();  // 使用迭代器的remove方法
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h1 id="MySQL面试题"><a href="#MySQL面试题" class="headerlink" title="MySQL面试题"></a>MySQL面试题</h1><h3 id="说说innodb和myisam的区别："><a href="#说说innodb和myisam的区别：" class="headerlink" title="说说innodb和myisam的区别："></a>说说innodb和myisam的区别：</h3><ul>
<li>innodb支持事务，默认支持行锁；MyISAM不支持事务，默认的锁是表锁</li>
<li>读写性能：Innodb增删改性能更优；MyISAM查询性能更优势</li>
</ul>
<h3 id="如何定位慢查询？"><a href="#如何定位慢查询？" class="headerlink" title="如何定位慢查询？"></a>如何定位慢查询？</h3><ul>
<li>开启慢查询日志，在MySQL的配置文件中设置 slow_query_log参数为1，设置慢查询日志的路径，设置慢查询的时间限制</li>
<li>找到慢查询的SQL后，可以用EXPLAIN命令查看MySQL是怎么执行SQL语句的</li>
</ul>
<h3 id="如何分析、优化不必要的列："><a href="#如何分析、优化不必要的列：" class="headerlink" title="如何分析、优化不必要的列："></a>如何分析、优化不必要的列：</h3><ul>
<li>用EXPLAIN命令查看，通过key和key_len查询是否命中了索引</li>
<li>通过type查看这条sql的连接类型，是否存在全索引扫描和全盘扫描</li>
<li>通过extra判断，是否出现回表，如果有，尝试添加索引挥着修改返回字段来修复</li>
<li>尽量避免select *，只查询需要的列，减少数据传输量</li>
</ul>
<h3 id="说说什么是索引："><a href="#说说什么是索引：" class="headerlink" title="说说什么是索引："></a>说说什么是索引：</h3><ul>
<li>索引是帮助MySQL高效获取数据的数据结构。数据库系统还维护者特定查找算法的数据结构（B+树），这些数据结构引用数据库数据，这样就可以在数据结构上实现高级查找算法，不用扫描整张表</li>
<li>提高数据检索成本。降低数据库io的成本</li>
<li>通过索引列对数据进行排序，降低数据排序成本，降低cpu功耗</li>
</ul>
<h3 id="说说索引的分类："><a href="#说说索引的分类：" class="headerlink" title="说说索引的分类："></a>说说索引的分类：</h3><ul>
<li>主键索引：每个表只能有一个主键索引，通常由主键列自动生成创建，主键索引是一种唯一索引，保证数据唯一性，不允许由null值</li>
<li>唯一索引：保证索引列的值唯一，可以有多个，允许由null值，适用于需要保证某列唯一性的场景</li>
<li>普通索引：最常见的索引类型，用于加速查询，不强制保证列的唯一性</li>
<li>组合索引：包含多个列的索引，用于提高联合查询的效率，列的顺序对查询性能由影响，查询时要按照索引中列的顺序使用索引</li>
<li>全文索引：用于对文本字段进行全文搜索，使用与搜索长文本数据，如文章内容、评论</li>
</ul>
<h3 id="索引的底层数据结构了解吗："><a href="#索引的底层数据结构了解吗：" class="headerlink" title="索引的底层数据结构了解吗："></a>索引的底层数据结构了解吗：</h3><ul>
<li>MySQL的InnoDB引擎采用了B+树的数据结构来存储索引</li>
<li>查询的阶数更多，一个节点可以包含更多的子节点。查询路径更短，B+树是平衡树。</li>
<li>磁盘读写代价更低，非叶子节点只存储指针，叶子节点存储数据</li>
<li>叶子节点是一个双向链表，B+树便于扫库和区间查询</li>
</ul>
<h3 id="说说B树和B-树的区别："><a href="#说说B树和B-树的区别：" class="headerlink" title="说说B树和B+树的区别："></a>说说B树和B+树的区别：</h3><ul>
<li>B树和B+树都是多路平衡查找树</li>
<li>B树中所有节点都存放数据；B+树只有叶子节点存放数据，其他节点存放key</li>
<li>B树叶子节点是独立的，B+树的叶子节点是通过链表与相邻的叶子节点连接</li>
<li>B树查找使用的二分查找，没有找到叶子节点就结束了；B+树必须从根节点查找，更稳定</li>
</ul>
<h3 id="请你说说索引怎么实现的B-树-为什么选这个数据结构？"><a href="#请你说说索引怎么实现的B-树-为什么选这个数据结构？" class="headerlink" title="请你说说索引怎么实现的B+树,为什么选这个数据结构？"></a>请你说说索引怎么实现的B+树,为什么选这个数据结构？</h3><ul>
<li>索引本质上通过预排序和树型结构提升检索效率，MySQL 的 InnoDB 和 MyISAM 引擎都使用 B+ 树来实现索引。</li>
<li>B+ 树是一种平衡多路查找树，相比二叉查找树，它降低了树的深度，从而减少了磁盘 IO 次数。</li>
<li>B+ 树的叶子节点存放着所有数据，并通过指针连接，实现快速的范围查找。通常，B+ 树的高度在 2～4 层，查找某一键值的行记录时最多需要 2～4 次 IO。B+ 树索引包括聚集索引和辅助索引，区别在于叶子节点是否存放完整行的信息。</li>
</ul>
<h3 id="什么是聚簇索引什么是非聚簇索引（二级索引）？什么是回表？"><a href="#什么是聚簇索引什么是非聚簇索引（二级索引）？什么是回表？" class="headerlink" title="什么是聚簇索引什么是非聚簇索引（二级索引）？什么是回表？"></a>什么是聚簇索引什么是非聚簇索引（二级索引）？什么是回表？</h3><ul>
<li>聚簇索引（聚集索引）：数据和索引放在一块，B+树的叶子节点保存了整行数据，有且只有一个</li>
<li>非聚簇索引（二级索引）：数据和索引分开存储，B+树的叶子节点存放对应的主键，可以有多个</li>
<li>回表查询：通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表</li>
<li>InnoDB 采用的是聚簇索引，如果没有显式定义主键，InnoDB 会选择一个唯一的非空列作为隐式的聚簇索引；如果这样的列也不存在，InnoDB 会自动生成一个隐藏的行 ID 作为聚簇索引。这意味着数据与主键是紧密绑定的，行数据直接存储在索引的叶子节点上。</li>
<li>MyISAM 采用的是非聚簇索引，表数据存储在一个地方，而索引存储在另一个地方，索引指向数据行的物理位置。</li>
</ul>
<h3 id="说说什么是覆盖查询？"><a href="#说说什么是覆盖查询？" class="headerlink" title="说说什么是覆盖查询？"></a>说说什么是覆盖查询？</h3><ul>
<li>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</li>
<li>当使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高</li>
<li>如果返回的列中没有创建索引，可能会触发回表查询，尽量避免使用select*</li>
</ul>
<h3 id="MySQL超大分页怎么处理？"><a href="#MySQL超大分页怎么处理？" class="headerlink" title="MySQL超大分页怎么处理？"></a>MySQL超大分页怎么处理？</h3><ul>
<li>在数据量较大的时候，limit分页查询会导致性能下降，因为偏移量大，需要跳过的行数多</li>
<li>优化方式是利用覆盖索引，用子查询获取需要的主键id，如何根据id再查找对应数据。</li>
<li>这样MySQL只需要扫描索引不用访问实际表数据，提高查询效率</li>
</ul>
<h3 id="说说事务的四大特性："><a href="#说说事务的四大特性：" class="headerlink" title="说说事务的四大特性："></a>说说事务的四大特性：</h3><ul>
<li>事务时一个或多个SQL语句组成的一个执行单元，这些语句要么全部执行完毕，要么全部不执行。事物的主要作用是保证数据库操作的一致性，对于维护数据库完整性非常重要</li>
<li>事务具有四个基本特性，简称ACID：<ul>
<li>原子性 Atomicity：事务是不可分割的整体，要么全部执行成功，要么执行失败回滚</li>
<li>一致性 Consistency：事务执行前后，数据库都要保持一致性状态，比如在账户转账的时候，应该保证转账前后两个账户的总金额保持不变、</li>
<li>隔离性 Isolation：事物的隔离性确保了并发事务之间互补干扰，用于解决并发执行时可能的问题，比如脏读、不可重复读、幻读，事务提交之前对其他的事务不可见。</li>
<li>MySQL提供了如 未提交、读已提交、可重复读、串行化来控制事务间的隔离程度</li>
<li>持久性 Durability：一旦事务提交，它对数据库的更改时永久性的，即使系统崩溃，数据库也能恢复到上一次提交的状态</li>
</ul>
</li>
</ul>
<h3 id="并发事务问题："><a href="#并发事务问题：" class="headerlink" title="并发事务问题："></a>并发事务问题：</h3><ul>
<li>脏读：一个事务读到另一个事务没有提交的数据</li>
<li>不可重复读：一个事务在先后两次读取同一段数据，但是两次的数据不同（在两次读取之间，有其他事务修改并提交了数据）</li>
<li>幻读：一个事务在条件查数据的时候，没有对应的数据行，但是在插入的时候又出现了这行数据（在两次查询中间，有其他事务插入了新的数据）</li>
</ul>
<h3 id="说说事务的隔离级别："><a href="#说说事务的隔离级别：" class="headerlink" title="说说事务的隔离级别："></a>说说事务的隔离级别：</h3><ul>
<li>MySQL提供四种隔离级别：读未提交、读已提交、可重复读、串行化</li>
<li><strong>读未提交</strong>：这个级别，事务可以读取其他事务未提交的更改，不能解决所有的并发问题，但是性能高、安全性低。<ul>
<li>比如：一个事务修改了数据，但是没有提交，另一个事务就会读取到未提交的数据，但是上一个事务可能会回滚，这将导致脏读</li>
</ul>
</li>
<li><strong>读已提交</strong>：在这个级别，事务只能读取到其他事务已经提交的更改。<ul>
<li>只能读取提交的更改避免了脏读，但是在事务执行的过程，如果其他事务不断提交更改，就会每次读到不一样的数据，会导致不可重复读、幻读</li>
</ul>
</li>
<li><strong>可重复读（MySQL默认）</strong>：在这个级别下，事务会在开始时创建一个快照，在整个事务过程中，所有的读取操作都是以这个快照为基础，所以相同的查询在同一事务中会返回相同的数据<ul>
<li>但是在某些情况下，会幻读，但是在MySQL，即使使用可重复读隔离级别，幻读通常也不会发生。这是因为事务在开始时使用快照读取数据，并且通过间隙锁防止其他事务插入新数据到查询范围内。</li>
</ul>
</li>
<li><strong>串行化</strong>：在这个级别下，所有事务依次顺序执行，避免并发操作带来的问题<ul>
<li>性能最差，但是可以避免所有问题</li>
</ul>
</li>
</ul>
<h3 id="说说undo-log和redo-log的区别："><a href="#说说undo-log和redo-log的区别：" class="headerlink" title="说说undo log和redo log的区别："></a>说说undo log和redo log的区别：</h3><ul>
<li><code>redo log</code> 和 <code>undo log</code> 是 MySQL 中用于保证事务可靠性的重要日志机制</li>
<li><code>redo log</code> 记录的是数据页的物理变化，用于保证事务的持久性，即使系统崩溃，已提交的事务也能通过 <code>redo log</code> 恢复</li>
<li><code>undo log</code> 记录的是数据修改前的状态，主要用于支持事务回滚，保证事务的原子性和一致性。在回滚时，<code>undo log</code> 可以撤销未提交的事务，将数据恢复到原始状态。</li>
<li>因此，<code>redo log</code> 确保了数据不丢失，而 <code>undo log</code> 确保了事务可以被正确撤销。</li>
</ul>
<h3 id="MySQL的主从同步是怎么实现的："><a href="#MySQL的主从同步是怎么实现的：" class="headerlink" title="MySQL的主从同步是怎么实现的："></a>MySQL的主从同步是怎么实现的：</h3><ul>
<li>主从同步的核心是二进制日志文件binlog，这个日志会记录所有的DDL（数据定义语言）和DML（数据操纵语言），但是不会包括数据查询语句</li>
<li>在主库事务提交时，会把数据变更记录在二进制日志Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay log中</li>
<li>从库重做中继日志中的事件，将改变反映他自己的数据</li>
</ul>
<h3 id="事务中的隔离性是怎么保证的？解释一下MVCC"><a href="#事务中的隔离性是怎么保证的？解释一下MVCC" class="headerlink" title="事务中的隔离性是怎么保证的？解释一下MVCC"></a>事务中的隔离性是怎么保证的？解释一下MVCC</h3><ul>
<li>锁：排他锁，一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁了</li>
<li>MVCC：多版本并发控制。是用来实现数据库并发控制的一种机制，通过保存数据的多个版本来允许多个事务同时读写操作</li>
<li>每个事务再开始时会创建一个快照，保证它在执行过程中看到的数据是一致的，即使其他事务同时修改数据，也能够有效实现数据库隔离性和一致性</li>
</ul>
<p>MVCC 是 MySQL InnoDB 存储引擎用来实现高并发环境下数据一致性的一种技术，它通过隐藏字段、<code>undo log</code>、版本链和 <code>ReadView</code> 来实现。在每一行记录中，InnoDB 会保存两个隐藏字段：<code>trx_id</code> 和 <code>roll_pointer</code>。<code>trx_id</code> 记录了最后修改该行记录的事务 ID，<code>roll_pointer</code> 则指向 <code>undo log</code>，保存了记录的旧版本数据。</p>
<p>这些旧版本数据通过 <code>roll_pointer</code> 形成了一个版本链，类似于一个链表结构，链中每个节点对应一次数据修改。版本链确保事务能够根据需要追溯到数据的历史版本，而 <code>undo log</code> 就是支撑这个版本链的日志系统。</p>
<p><code>undo log</code> 记录了事务修改数据前的状态，不仅用于事务回滚，也为 MVCC 提供了多版本的数据。在数据读取时，InnoDB 会根据 <code>ReadView</code> 来决定哪些版本对当前事务可见。<code>ReadView</code> 包含当前活跃事务的列表和其他元数据，用于判断一个数据版本是否可以被当前事务读取。</p>
<p>当事务读取的数据版本对当前事务不可见时，InnoDB 会沿着版本链，通过 <code>undo log</code> 逐个回溯，直到找到一个可见的版本。因此，MVCC 能在高并发场景下，通过提供一致性视图，实现事务的隔离性，避免加锁带来的性能问题，同时确保数据的一致性和隔离性，特别是在可重复读（Repeatable Read）隔离级别下有效避免幻读问题。</p>
<h3 id="了解分库分表吗？"><a href="#了解分库分表吗？" class="headerlink" title="了解分库分表吗？"></a>了解分库分表吗？</h3><ul>
<li>水平分库：将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题</li>
<li>水平分表：解决单表存储的性能问题</li>
<li>垂直分库：根据业务进行拆分，高并发下提高磁盘IO和网络连接数</li>
<li>垂直分表，冷热数据分离，多表互不影响，比如一个文章表由基础信息和描述组成，可以将描述和主键id分出一张表</li>
</ul>
<h3 id="请你说说乐观锁和悲观锁"><a href="#请你说说乐观锁和悲观锁" class="headerlink" title="请你说说乐观锁和悲观锁"></a>请你说说乐观锁和悲观锁</h3><ul>
<li>乐观锁总是假设最好的情况，认为数据的变动不会太频繁，通常时在表中添加一个版本号或时间戳</li>
<li>在事务从数据库中取数据的是时候，会将版本号也取出，当事务对数据处理完毕后想要更新到表中，会取出之前版本与数据中最新的版本对比，如果v1&#x3D;v2，说明在数据变动期间，没有其他事务对数据进行修改，此时允许事务对表中数据进行修改，而且修改时版本号加1，表明该数据被变动</li>
<li>如果，v1 不等于 v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</li>
<li>悲观锁总是假设最坏的情况，认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，所以每次在拿数据时都会上锁，这样别人想拿这个数据时会阻塞直到拿到锁。一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</li>
<li>mysql数据库的共享锁和排他锁都是悲观锁的实现。</li>
</ul>
<h1 id="Spring框架面试题"><a href="#Spring框架面试题" class="headerlink" title="Spring框架面试题"></a>Spring框架面试题</h1><h3 id="介绍一下Spring"><a href="#介绍一下Spring" class="headerlink" title="介绍一下Spring"></a>介绍一下Spring</h3><ul>
<li>Spring是一个轻量级的企业应用开发框架，他有众多模块，其中core模块是spring的核心模块，spring的核心功能IOC和Aop都是都是该模块提供的。</li>
<li>IOC就是控制反转的意思，他将对象的创建和管理交给IOC容器，来实现程序的解耦。IOC通过依赖注入来实现，依赖注入的概念就是说你不用创建对象，而只需要描述它如何被创建。依赖注入有set注入，构造方法注入、注解注入等方式。</li>
<li>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。在Aop的思想下，我们可以通过不修改原来代码的前提下给系统添加功能。通常用于事务和日志管理。</li>
</ul>
<h3 id="说说对Spring-Boot的理解，以及和Spring的区别？"><a href="#说说对Spring-Boot的理解，以及和Spring的区别？" class="headerlink" title="说说对Spring Boot的理解，以及和Spring的区别？"></a>说说对Spring Boot的理解，以及和Spring的区别？</h3><ul>
<li>Spring Boot是基于Spring框架的快速开发工具，使用“习惯优于配置”的理念让项目快速的运行起来。</li>
<li>Spring Boot本身不提供Spring的核心功能，而是作为Spring的脚手架框架。通过内嵌Web服务器、自动配置、简化的依赖管理和丰富的starter包，达到快速构建项目。</li>
<li>自动配置：针对很多Spring应用程序常见的引用功能，Spring Boot都能自动提供相关的配置</li>
<li>起步依赖：Spring Boot通过起步依赖为项目的依赖管理提供帮助。起步依赖就是特殊的Maven依赖和Gradle依赖，利用传递依赖解析，把常用的库聚合在一起，组成了几个为特定功能而定制的依赖</li>
<li>端点监控：Spring Boot可以对正在运行的项目提供监控</li>
</ul>
<p><strong>Spring与Spring Boot的区别</strong>：Spring是一个全面的应用开发框架，提供了丰富的功能和灵活性，但需要大量的手动配置。Spring Boot在此基础上进行了封装，提供了开箱即用的功能，自动化了许多配置工作，减少了开发者的工作量。简单来说，Spring关注的是如何实现各种功能，而Spring Boot则关注如何快速、便捷地启动并运行Spring应用。</p>
<h3 id="说说Spring-Boot常用的注解："><a href="#说说Spring-Boot常用的注解：" class="headerlink" title="说说Spring Boot常用的注解："></a>说说Spring Boot常用的注解：</h3><ul>
<li>Spring注解：<ul>
<li><strong>@Component、@Controller、@Service、@Repository：</strong>使用在类上用于实例化Bean</li>
<li><strong>@Autowired：</strong>使用在字段上，用于根据类型依赖注入</li>
<li><strong>@Scope：</strong>用于标注Bean的作用范围</li>
<li><strong>@Configuration：</strong>用于指定当前类是一个Spring配置类，当创建容器的时候会从该类上加载注解，配置类可以包含一个或多个 <code>@Bean</code> 方法，这些方法的返回值会被Spring容器管理，作为Spring Bean。</li>
<li><strong>@ComponentScan：</strong>用于指定Spring在初始化容器时要扫描的包</li>
<li><strong>@Bean：</strong>使用在方法上，标注将该方法的返回值存储到Spring容器中</li>
<li><strong>@Import：</strong>使用这个注解导入的类会被Spring加载到ioc容器中</li>
<li><strong>@Aspect、@Before、@After、@Around、@Pointcut：</strong>用于切面编程AOP</li>
</ul>
</li>
<li>SpringMVC注解：<ul>
<li><strong>@RequestMapping：</strong>用于映射请求路径,可以定义在类上和方法上。用于类上,则表示类中的所有的方法都是以该地址作为父路径</li>
<li><strong>@RequestBody：</strong>注解实现接收http请求的json数据，将json转换为java对象</li>
<li><strong>@RequestParam：</strong>指定请求参数的名称</li>
<li><strong>@PathViriable：</strong>从请求路径下中获取请求参数(&#x2F;user&#x2F;fid})，传递给方法的形式参数</li>
<li><strong>@ResponseBody：</strong>注解实现将controller方法返回对象转化为json对象响应给客户端</li>
<li><strong>@RequestHeader：</strong>获取指定的请求头数据</li>
<li><strong>@RestController：</strong>代表 @Controller + @ResponseBody</li>
</ul>
</li>
<li>Spring Boot注解：<ul>
<li><strong>@SpringBootConfiguration：</strong>组合了@Configuration，实现了配置文件的功能。不仅继承了 <code>@Configuration</code> 的所有功能，还能够与Spring Boot的其他特性（如自动配置、外部化配置等）紧密结合</li>
<li><strong>@EnableAutoConfiguration：</strong>打开自动配置功能，在启动Spring应用程序上下文时进行自动配置，自动配置通常是基于项目classpath中引入的类和已定义的bean来实现的。</li>
<li><strong>@Import：</strong>@EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。 </li>
<li><strong>@ComponentScan：</strong>Spring组件扫描</li>
<li><strong>@SpringBootApplication</strong>：是由@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan组成的</li>
</ul>
</li>
</ul>
<h3 id="Spring-如何管理-Controller"><a href="#Spring-如何管理-Controller" class="headerlink" title="Spring 如何管理 @Controller"></a>Spring 如何管理 <code>@Controller</code></h3><ul>
<li>当Spring应用启动时，Spring容器会扫描类路径下的包，找到带有<code>@Controller</code>注解的类，并将它们实例化为Spring Bean，放入IoC容器中进行管理。</li>
<li>然后，Spring MVC会根据配置将这些控制器中的方法映射到对应的HTTP请求上。</li>
</ul>
<h3 id="说说单例Bean和多例Bean的区别和用途："><a href="#说说单例Bean和多例Bean的区别和用途：" class="headerlink" title="说说单例Bean和多例Bean的区别和用途："></a>说说单例Bean和多例Bean的区别和用途：</h3><ul>
<li>在Spring框架中，Bean的作用域决定了其在应用中的生命周期和实例数量。</li>
<li><strong>单例Bean</strong>（<code>@Singleton</code>）是Spring默认的作用域，它在整个Spring容器中只有一个实例。适用于无状态的服务或需要共享状态的组件，比如工具类和配置管理器。单例Bean能够提高性能，因为它避免了重复创建对象的开销，并且减少了内存消耗。然而，由于所有线程共享同一个实例，单例Bean在多线程环境中需要确保线程安全。</li>
<li><strong>多例Bean</strong>（<code>@Scope(&quot;prototype&quot;)</code>）每次请求都会创建一个新的实例。这种作用域适合于那些需要保持独立状态的场景，比如用户会话信息、动态内容生成或需要与用户交互的组件。每次获取多例Bean时，都会返回一个新的对象实例，这样可以确保每个请求或操作都有一个全新的对象，避免了不同请求间的数据干扰。</li>
<li>选择单例Bean还是多例Bean，主要取决于具体的使用场景和需求。单例Bean适合需要共享状态、希望提高性能的情况，而多例Bean适合需要独立对象、维护状态的场景。正确选择作用域能够优化资源使用，提升应用的稳定性和性能。</li>
</ul>
<h3 id="说说对单例bean的理解，这是线程安全的吗？："><a href="#说说对单例bean的理解，这是线程安全的吗？：" class="headerlink" title="说说对单例bean的理解，这是线程安全的吗？："></a>说说对单例bean的理解，这是线程安全的吗？：</h3><ul>
<li>Spring框架用默认的单例Bean创建对象，如果Spring的Bean里面都是注入无状态的对象（可以理解为这个Bean不会保持任何客户端或请求的特定状态，并且不提供对内部状态的修改操作），那么是线程安全的。</li>
<li>无状态的Bean包括 Service类、DAO类。</li>
<li>如果在Bean中定义了可修改的成员变量，那么线程不安全，可以使用多例或者加锁来解决。最简单解决方法是将Bean的作用域改为“prototype”。</li>
</ul>
<h3 id="说说Spring-Boot的起步依赖："><a href="#说说Spring-Boot的起步依赖：" class="headerlink" title="说说Spring Boot的起步依赖："></a>说说Spring Boot的起步依赖：</h3><ul>
<li>starter配置，约定大于配置，spring boot将日常企业应用研发中的各种场景都抽取出来，做成一个个的starter（启动器），starter中整合了该场景下各种可能用带的依赖，用户只需要在Maven中引入starter依赖，spring boot就能自动扫描到要加载的信息并启动响应的默认配置</li>
</ul>
<h3 id="说说Spring-Boot的启动流程："><a href="#说说Spring-Boot的启动流程：" class="headerlink" title="说说Spring Boot的启动流程："></a>说说Spring Boot的启动流程：</h3><ul>
<li>通过SpringApplication注解找到Spring Boot的入口类，通过main方法调用SpringApplication静态方法的run方法来实例化一个SpringApplication对象</li>
<li>再调用这个对象的run方法，获取监听器的配置、打印Banner信息、创建并初始化容器</li>
<li>监听器发送通知，这就完成了项目的初始化和启动</li>
</ul>
<h3 id="说说Spring-Boot的自动装配原理："><a href="#说说Spring-Boot的自动装配原理：" class="headerlink" title="说说Spring Boot的自动装配原理："></a>说说Spring Boot的自动装配原理：</h3><ul>
<li>在Spring Boot项目中，<code>@SpringBootApplication</code>是一个复合注解，封装了<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、和<code>@ComponentScan</code>三个注解。</li>
<li>其中，<code>@EnableAutoConfiguration</code>是实现自动配置的关键。它通过<code>@Import</code>注解引入了配置选择器，读取项目和依赖的Jar包中的<code>META-INF/spring.factories</code>文件，这个文件中定义了自动配置类的全类名。Spring Boot会根据这些配置类中的条件注解（如<code>@ConditionalOnClass</code>）判断是否加载相应的Bean到Spring容器中，实现自动装配。</li>
</ul>
<h3 id="说说对IOC的理解："><a href="#说说对IOC的理解：" class="headerlink" title="说说对IOC的理解："></a>说说对IOC的理解：</h3><ul>
<li>IOC是什么：IOC全称是Inversion of Controller，也就是控制反转。他的核心思想是把对象的管理权限交给了容器，如果程序如果需要使用某个对象的实例，直接从IOC容器中获取即可。这种设计的好处在于：降低了程序里面，对象与对象之间的耦合性，使得程序的整个体系结构更加灵活。</li>
<li>Bean的声明方式：Spring提供了很多方式声明Bean，比如在XML配置文件中通过<bean>标签、通过各种注解（@Component、@Service）、通过@Configuration配置类里面通过@Bean注解声明</li>
<li>Spring在启动的时候会去解析这些Bean，然后保存到IOC容器里面</li>
</ul>
<h3 id="IOC的工作流程："><a href="#IOC的工作流程：" class="headerlink" title="IOC的工作流程："></a>IOC的工作流程：</h3><ul>
<li><strong>IOC容器的初始化阶段：</strong>根据程序里定义的XML或者Bean，通过解析和加载后生成BeanDefinition，然后把BeanDefinition注册到IOC容器里面。通过注解或者XML声明的Bean都会解析为一个BeanDefinition实体，这个实体里会包含Bean的一些定义和基本属性，最后把BeanDefinition保存到一个Map集合里，从而完成IOC的初始化</li>
<li>IOC容器的作用就是对这些注册的Bean定义信息，进行处理和维护，是IOC容器控制反转的核心</li>
<li><strong>完成Bean初始化和依赖注入：</strong>通过反射对没有设置懒加载的单例Bean进行初始化，完成Bean的依赖注入</li>
<li><strong>Bean的使用：</strong>通过@Autowired注解，或者通过BeanFactory.getBean()，从IOC容器中获取一个指定的Bean实例。另外针对懒加载属性@Lazy（或XML中的 lazy-init属性为true），以及非单例Bean的实例化，实在每一次获取Bean对象的时候，调用Bean的实例化方法，来完成实例化的，并且SpringIOC容器不会去管理这些Bean</li>
</ul>
<h3 id="Bean创建管理方式有哪些？"><a href="#Bean创建管理方式有哪些？" class="headerlink" title="Bean创建管理方式有哪些？"></a>Bean创建管理方式有哪些？</h3><ul>
<li><strong>@Service、@Component、@Repository等注解：</strong><ul>
<li>用于表示普通业务类、组件、DAO，这些类通常不需要复杂的初始化和销毁逻辑</li>
<li>当你在类上使用这些注解时，Spring会自动将这个类注册为Bean，并将其纳入到Spring容器的管理中。它们属于Spring的组件扫描机制的一部分，会自动检测到并实例化这些类。</li>
<li>对于普通的<code>@Service</code>类，如果没有明确的资源需要释放（如文件、数据库连接等），Spring不会执行任何额外的销毁逻辑，只会销毁对象的引用。</li>
</ul>
</li>
<li><strong>@Bean注解：</strong><ul>
<li>当你需要对Bean进行更精细的控制，比如在创建Bean时需要提供额外的构造参数、动态决定Bean的生成，或者条件性地创建Bean时。</li>
<li><code>@Bean</code>通常用于配置类中（带有<code>@Configuration</code>的类），它可以让你在方法中手动创建和返回一个Bean实例，并将其注册到Spring容器中。</li>
<li><strong>自定义初始化和销毁方法：</strong><ul>
<li>使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解，标记在Bean初始化和销毁时要执行的方法。</li>
<li>在 <code>@Bean</code> 注解中指定 <code>initMethod</code> 和 <code>destroyMethod</code> 参数，指定自定义的初始化和销毁方法。</li>
<li>实现 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口，分别定义 <code>afterPropertiesSet()</code> 和 <code>destroy()</code> 方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Bean的生命周期："><a href="#Bean的生命周期：" class="headerlink" title="Bean的生命周期："></a>Bean的生命周期：</h3><ul>
<li><strong>实例化：</strong>在Spring容器启动时，首先会根据配置（如XML配置、注解或Java配置类）扫描和加载Bean定义，并将这些定义转换为 <code>BeanDefinition</code> 对象。<ul>
<li>随后，Spring容器通过反射机制实例化Bean对象，容器调用静态工厂或者调用已存在的Bean实例方法（实例工厂）来创建Bean实例，这个过程就是Bean的实例化阶段。在这个阶段，Bean只是一个简单的Java对象，还未进行依赖注入。</li>
</ul>
</li>
<li><strong>依赖注入：</strong>将Bean所需的依赖对象注入到该Bean中。依赖注入可以通过构造器、setter方法或字段注入的方式进行。如果Bean实现了 <code>BeanNameAware</code>、<code>BeanFactoryAware</code> 等Aware接口，Spring会在此阶段调用相应的接口方法，将Bean在Spring容器中的相关信息传递给Bean，例如Bean的名字或所属的BeanFactory。</li>
<li><strong>初始化：</strong>在依赖注入完成后，Spring会对Bean进行初始化操作。<ul>
<li>这个阶段可以通过几种方式进行：首先，如果Bean实现了 <code>InitializingBean</code> 接口，Spring会调用其 <code>afterPropertiesSet()</code> 方法；其次，如果Bean的方法上标注了 <code>@PostConstruct</code> 注解，Spring会执行这个方法；最后，如果在配置中通过 <code>@Bean</code> 注解指定了 <code>initMethod</code>，Spring会执行该方法。这一阶段通常用于执行一些需要在Bean使用之前完成的初始化逻辑，如资源加载、连接建立等。</li>
</ul>
</li>
<li><strong>销毁实例：</strong>当Spring容器关闭或Bean被销毁时，Spring会进入Bean的销毁阶段。<ul>
<li>与初始化类似，销毁阶段也可以通过几种方式实现：首先，若Bean实现了 <code>DisposableBean</code> 接口，Spring会调用其 <code>destroy()</code> 方法；其次，Spring会执行标注有 <code>@PreDestroy</code> 注解的方法；最后，如果在配置中通过 <code>@Bean</code> 注解指定了 <code>destroyMethod</code>，Spring也会执行该方法。销毁阶段主要用于释放资源，如关闭数据库连接或停止线程池等。</li>
</ul>
</li>
</ul>
<h3 id="说说BeanFactory和FactoryBean的区别："><a href="#说说BeanFactory和FactoryBean的区别：" class="headerlink" title="说说BeanFactory和FactoryBean的区别："></a>说说BeanFactory和FactoryBean的区别：</h3><ul>
<li>BeanFactory：是所有spring bean容器的顶级接口，是最基础的IOC容器，它为spring的容器定义了一套方法，并提供像getBean这样的方法从容器中获取指定的bean实例。它在产生bean的同时，还提供了解决bean之间的依赖注入的能力，也就是所谓的di。</li>
<li>FactoryBean：工厂bean，只是SpringIOC容器创建Bean的一种形式，它是一个接口，它的主要功能是动态去生成某一类型的bean的一个实例，也就是说 我们可以自定义一个bean并且加载到ioc容器里面，getObject是用来实现动态构建bean的一个过程。 </li>
<li>与普通Bean不同，<code>FactoryBean</code>本身不是要创建的Bean，而是用来生成实际Bean实例的工厂。通过<code>FactoryBean</code>，可以控制Bean的创建过程，甚至可以返回不同类型的Bean实例。</li>
</ul>
<h3 id="说说-Autowired和-Resource注解的区别："><a href="#说说-Autowired和-Resource注解的区别：" class="headerlink" title="说说@Autowired和@Resource注解的区别："></a>说说@Autowired和@Resource注解的区别：</h3><ul>
<li>@Autowied是Spring提供的注解，@Resource是JDK提供的注解。</li>
<li>@Autowied是只能按类型注入，@Resource默认按名称注入，也支持按类型注入。</li>
<li>@Autowired按类型装配依赖对象,默认情况下它要求依赖对象必须存在,如果允许null值,可以设置它required属性为false,如果我们想使用按名称装配,可以结合@Qualifier注解一起使用</li>
</ul>
<h3 id="什么是AOP，对AOP的理解？"><a href="#什么是AOP，对AOP的理解？" class="headerlink" title="什么是AOP，对AOP的理解？"></a>什么是AOP，对AOP的理解？</h3><ul>
<li>AOP是面向切面编程，用于将那些与业务无关的，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合</li>
<li>简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加简洁。</li>
<li>AOP是面向切面编程，它是一种编程思想，它是一种通过预编译方式和运行期间动态代理的方式实现不修改源代码的情况下给程序动态添加功能的一种技术，可以降低代码的耦合度，便于管理，提高代码的可重用性。 AOP的实现方式有两种： JDK动态代理，可以在运行时创建接口的代理实例。 CGLIB动态代理：可以在运行期间创建子类的动态实例。 AOP的应用场景有：事务，日志管理等。</li>
</ul>
<h3 id="项目中有没有用到AOP："><a href="#项目中有没有用到AOP：" class="headerlink" title="项目中有没有用到AOP："></a>项目中有没有用到AOP：</h3><ul>
<li>用于记录操作日志、缓存、Spring实现的事务</li>
<li>使用AOP中的环绕通知+切点表达式（找到记录日志的方法），通过环绕统治的参数获取请求方法的参数（类、方法、注解、请求方式），获取到这些参数后，保存到数据库</li>
<li>详细在项目面试点</li>
</ul>
<h3 id="说说-JDK-动态代理和-CGLIB-代理？"><a href="#说说-JDK-动态代理和-CGLIB-代理？" class="headerlink" title="说说 JDK 动态代理和 CGLIB 代理？"></a>说说 JDK 动态代理和 CGLIB 代理？</h3><ul>
<li>JDK 动态代理是基于接口的代理，只能代理实现了接口的类。使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑。</li>
<li>CGLIB 动态代理是基于继承的代理，可以代理没有实现接口的类。使用 CGLIB 动态代理时，Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑。</li>
</ul>
<h3 id="Spring中的事务是如何实现的："><a href="#Spring中的事务是如何实现的：" class="headerlink" title="Spring中的事务是如何实现的："></a>Spring中的事务是如何实现的：</h3><ul>
<li>本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行目标方法之后根据执行情况提交或者回滚事务</li>
<li>①编程式事务管理使用TransactionTemplate。 </li>
<li>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 </li>
<li>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</li>
</ul>
<h3 id="说说Bean的作用域，默认作用域："><a href="#说说Bean的作用域，默认作用域：" class="headerlink" title="说说Bean的作用域，默认作用域："></a>说说Bean的作用域，默认作用域：</h3><ul>
<li><strong>1. Singleton（单例）</strong>：这是Spring Bean的默认作用域。当一个Bean被声明为Singleton时，Spring容器在创建时只会实例化该Bean一次，并在整个应用上下文中共享该实例。无论有多少个调用者或依赖该Bean的类，都会引用同一个实例。单例作用域适用于无状态的Bean，例如DAO、服务类等，它们在整个应用程序生命周期中保持相同的行为。</li>
<li><strong>2. Prototype（原型）</strong>：与Singleton相反，当Bean的作用域为Prototype时，每次请求该Bean时，Spring都会创建一个新的实例。这种作用域适用于那些需要在每次使用时都拥有全新状态的Bean，例如需要临时保存数据的对象。由于每次请求都会创建新实例，因此需要注意对这些Bean的资源管理和清理。</li>
<li><strong>3. Request</strong>：这种作用域仅适用于Web应用程序。在Request作用域中，Bean实例在每个HTTP请求的生命周期内被创建并使用，在请求处理完毕后销毁。它适用于与单个HTTP请求关联的组件，例如处理用户请求的控制器或过滤器。</li>
<li><strong>4. Session</strong>：同样适用于Web应用程序，在Session作用域中，Bean实例在每个HTTP会话（Session）期间被创建和共享。当用户会话结束时，Bean实例也会被销毁。Session作用域适用于需要保存用户会话信息的组件，例如用户购物车或用户偏好设置。</li>
<li><strong>5. Application</strong>：在Servlet上下文中，Bean实例在整个Web应用程序生命周期内共享。这意味着所有请求和会话都将共享同一个实例，类似于单例作用域，但适用于Web应用程序的全局环境。</li>
</ul>
<h3 id="说说对MVC的理解："><a href="#说说对MVC的理解：" class="headerlink" title="说说对MVC的理解："></a>说说对MVC的理解：</h3><ul>
<li>MVC是一种设计模式，在这个模式下软件被分为三层：Model模型、View视图、Controller控制器</li>
<li>将软件分层的好处是 可  以将对象之间的耦合度降低，便于代码的维护。</li>
<li>Model封装了数据及其操作，是应用程序中处理和管理数据的核心部分。它负责与数据库或其他数据源进行交互，并执行业务逻辑。</li>
<li>View负责将模型中的数据展示给用户，它通常就是用户界面，用来呈现数据并与用户进行交互。</li>
<li>Controller作为控制器，在Model和View之间起到桥梁作用，主要负责处理用户请求并将其分发到相应的Model中进行处理，同时将Model的变化反馈给View，以便及时更新用户界面。Controller确保模型的状态与视图保持同步，从而实现用户请求的响应。</li>
<li>在Spring MVC框架中，<code>DispatcherServlet</code>作为前端控制器接收所有请求，并通过<code>HandlerMapping</code>将请求映射到具体的<code>Controller</code>处理。<code>Controller</code>处理请求并返回视图名，<code>ViewResolver</code>则负责解析视图名并渲染最终的视图页面。这些组件协同工作，实现了Spring MVC中Model-View-Controller的架构模式。</li>
</ul>
<h3 id="说说对Spring-MVC的理解："><a href="#说说对Spring-MVC的理解：" class="headerlink" title="说说对Spring MVC的理解："></a>说说对Spring MVC的理解：</h3><ul>
<li>SpringMVC是Spring生态中的一个模块，是在Servlet基础上构建并且使用了MVC模式设计的一个Web框架。主要目的是为了简化传统的Servlet + JSP模式下的Web开发方式。</li>
<li>SpringMVC整个架构设计是对JavaWeb里面的MVC框架模式做了增强和扩展，主要体现在几个方面：<ul>
<li>把传统的MVC框架里面的Controller控制器做了拆分，分成了前端控制器DispatcherServlet和后端控制器Controller。</li>
<li>把Model模型拆分成了业务层Service和数据访问层Repository。</li>
<li>在视图层，可以支持不同的视图，比如Freemark、velocity、JSP、Thymeleaf …</li>
</ul>
</li>
</ul>
<h3 id="说说SpringMVC的执行流程："><a href="#说说SpringMVC的执行流程：" class="headerlink" title="说说SpringMVC的执行流程："></a>说说SpringMVC的执行流程：</h3><ul>
<li>用户提交的Http请求提交给前端控制器(dispatcher)之后,前端控制器调用处理器映射器(HandlerMapper)来解析用户提交的路径， 处理器映射器处理好之后会返回一个处理器的信息给前端控制器， 前端控制器再将处理器的信息发送给处理器适配器(HandlerAdaper)，处理器适配器通过前端控制器提交的处理器的信息去找到相应的处理器(Handler)并执行， 执行成功后返回一个ModelAndView的对象给处理器适配器，处理器适配器返回给前端控制器， 前端控制器会请求视图解析器(ViewResolver)，对ModelAndView对象对视图处理，视图解析器根据View的信息匹配到对象的视图，并将其返回给前端控制器 前端控制器获取到具体的视图后，将存储在Model中的数据对视图进行渲染，生成最终的视图， 视图将结果显示到浏览器</li>
<li>用户点击某个请求路径,发起一个 HTTP request 请求,该请求会被提交到前端控制器(DispatcherServlet)； </li>
<li>由 DispatcherServlet 请求一个或多个处理器映射器(HandlerMapping),并返回一个执行链(HandlerExecutionChain)。 </li>
<li>DispatcherServlet 将执行链返回的 Handler 信息发送给处理器适配器(HandlerAdapter)； </li>
<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler(常称为 Controller)； </li>
<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象(Spring MVC的底层对象,包括 Model 数据模型和 View 视图信息)； </li>
<li>HandlerAdapter 接收到 ModelAndView 对象后,将其返回给 DispatcherServlet ； </li>
<li>DispatcherServlet 接收到 ModelAndView 对象后,会请求视图解析器(ViewResolver)对视图进行解析； </li>
<li>ViewResolver 根据 View 信息匹配到相应的视图结果,并返回给 DispatcherServlet； </li>
<li>DispatcherServlet 接收到具体的 View 视图后,进行视图渲染,将 Model 中的模型数据填充到 View 视图中的 request 域,生成最终的 View(视图)； </li>
<li>视图负责将结果显示到浏览器(客户端)。</li>
</ul>
<h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1>

<h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><h1 id="技术派项目面试点"><a href="#技术派项目面试点" class="headerlink" title="技术派项目面试点"></a>技术派项目面试点</h1><h3 id="使用-AOP-TraceID-AOP-TraceID-记录接口访问日志，实现任务追踪和监控："><a href="#使用-AOP-TraceID-AOP-TraceID-记录接口访问日志，实现任务追踪和监控：" class="headerlink" title="使用 AOP + TraceID  AOP + TraceID 记录接口访问日志，实现任务追踪和监控："></a>使用 AOP + TraceID  AOP + TraceID 记录接口访问日志，实现任务追踪和监控：</h3><ul>
<li>在项目中，我们使用AOP（面向切面编程）来实现接口访问日志的记录和追踪，主要是为了在分布式系统和微服务架构中有效地监控和分析每个请求的执行路径。AOP的使用在这个过程中起到了核心作用，通过定义切面拦截所有需要记录日志的方法调用，实现了日志的自动化处理和上下文管理。</li>
<li>具体来说，我们创建了一个AOP切面类<code>MdcAspect</code>，用于拦截所有标注了特定注解<code>@MdcDot</code>的方法或类。这个注解应用在需要日志记录的地方，例如控制器方法中。在方法执行前，切面会自动执行一段逻辑来生成一个唯一的Trace ID。这是通过自定义的Trace ID生成器实现的，生成的Trace ID可以包含丰富的上下文信息，如IP地址、时间戳、进程号等。然后，这个Trace ID被添加到MDC（Mapped Diagnostic Context）中，这是一个用于多线程环境下存储线程特定诊断信息的机制。</li>
<li>切面在方法执行之前还会将业务代码（bizCode）等信息添加到MDC中，确保这些信息在日志中完整记录。通过<code>@Around</code>通知类型的使用，切面能够在目标方法执行前后进行逻辑的插入和操作。在方法执行期间，切面通过<code>ProceedingJoinPoint</code>对象执行实际的方法调用并获取返回结果。在方法执行结束后，切面会自动记录方法的执行时间，并将其以INFO级别的日志输出，方便监控和分析。</li>
<li>此外，切面还负责在方法执行完毕后清理MDC中的Trace ID和业务代码，防止这些上下文信息在后续请求处理中被错误复用。这种通过AOP实现的日志记录方式非常灵活和高效，它将日志记录逻辑从业务代码中分离出来，避免了代码的重复和耦合，使系统的可维护性和可扩展性得到了极大的提升。在实现过程中，我们只需在需要的地方使用<code>@MdcDot</code>注解，AOP切面就会自动处理日志的记录和上下文的管理，这极大简化了日志记录的实现方式，并增强了系统的可观察性和问题排查能力。</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论。 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
