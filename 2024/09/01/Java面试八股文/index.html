<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java面试八股文 | spikenauy&#39;s blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="Java面试八股文 | spikenauy&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="JAVA面试题基础语法java基本类型分为八大类型：整数类型：byte，short，int，long	浮点类型：float，double 字符类型：char	布尔类型：boolean  byte：1字节 8位	short：2字节 16位	int：4字节 32位	long：8字节 64位	 float：4字节 32位	double：8字节 64位 char：2字节 16位	boolean：不同jvm">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试八股文">
<meta property="og:url" content="http://spikenauy.github.io/2024/09/01/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="spikenauy&#39;s blog">
<meta property="og:description" content="JAVA面试题基础语法java基本类型分为八大类型：整数类型：byte，short，int，long	浮点类型：float，double 字符类型：char	布尔类型：boolean  byte：1字节 8位	short：2字节 16位	int：4字节 32位	long：8字节 64位	 float：4字节 32位	double：8字节 64位 char：2字节 16位	boolean：不同jvm">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-31T17:18:12.000Z">
<meta property="article:modified_time" content="2024-09-06T07:07:59.479Z">
<meta property="article:author" content="spikenauy">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>spikenauy</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(3)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="-工具">
            
            -工具
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="-面试">
            
            -面试
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="-数据库">
            
            -数据库
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 -面试 "
           href="/2024/09/01/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java面试八股文">Java面试八股文</span>
            <span class="post-date" title="2024-09-01 01:18:12">2024/09/01</span>
        </a>
        
        
        <a  class="全部文章 -数据库 "
           href="/2024/07/15/MySQL%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL笔记">MySQL笔记</span>
            <span class="post-date" title="2024-07-15 10:01:07">2024/07/15</span>
        </a>
        
        
        <a  class="全部文章 -工具 "
           href="/2024/07/15/Git-%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git 笔记">Git 笔记</span>
            <span class="post-date" title="2024-07-15 09:57:37">2024/07/15</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Java面试八股文" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java面试八股文</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="-面试">-面试</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-09-06 15:07:59'>2024-09-01 01:18</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">JAVA面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%88%86%E4%B8%BA%E5%85%AB%E5%A4%A7%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">java基本类型分为八大类型：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说面向对象的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4final%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-text">说说final关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4static%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-text">说说static修饰符的用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">抽象类和接口的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4hashCode-%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E5%B0%B1%E8%A6%81%E9%87%8D%E5%86%99hashCode-%EF%BC%9A"><span class="toc-text">说说hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-%E4%B8%8Eequals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">请你说说&#x3D;&#x3D;与equals()的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E9%87%8D%E8%BD%BD%E7%9A%84%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说重载的重写的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%83%BD%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99%EF%BC%9A"><span class="toc-text">说说构造方法能不能重写：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4String%E7%B1%BB-%E4%BB%A5%E5%8F%8Anew%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B4%E6%8E%A5%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说String类,以及new和字符串直接量的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">String、StringBuilder、StringBuffer有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">说说Java的异常处理机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4java%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-text">说说java有哪些异常：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-text">I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4java-IO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">说说java IO流分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4BIO%E3%80%81NIO%E3%80%81AIO%EF%BC%9A"><span class="toc-text">说说BIO、NIO、AIO：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BA%86%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%9F"><span class="toc-text">有了字节流为什么要有字符流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">说说Java中的编码问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4utf-8-%E5%92%8Cutfmb4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说utf-8 和utfmb4的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A"><span class="toc-text">说说序列化、反序列化：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%B3%9B%E5%9E%8B%E3%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9A"><span class="toc-text">说说泛型、类型擦除：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E5%8F%8D%E5%B0%84%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对反射的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9C%A8%E6%A1%86%E6%9E%B6%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">反射在框架工具类中的应用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">JDK 1.8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BJava-8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-text">讲一下Java 8的新特性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">Java并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-text">说说多线程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-text">说说多线程的注意点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">说说线程的创建方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">说说线程的状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4wait%EF%BC%88%EF%BC%89%E5%92%8Csleep%EF%BC%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说wait（）和sleep（）的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A"><span class="toc-text">说说怎么保证线程安全：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">说说你了解的线程同步方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">说说你了解的线程通信方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说Java中常用的锁和原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说synchronized和lock的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4synchronized%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说synchronized的原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9AQS%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说你对AQS的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对线程池的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4volatile%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说volatile的用法和原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9threadlocal%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对threadlocal的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JUC%EF%BC%9A"><span class="toc-text">说说JUC：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E6%9D%A5CAS%EF%BC%9F"><span class="toc-text">java哪些地方用来CAS？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9java%E9%9B%86%E5%90%88%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对java集合的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-text">说说线程安全的集合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">说说HashMap的底层原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说HashMap和HashTable的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">HashMap是线程安全的吗？如果不是该如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4ConcurrentHashMap%EF%BC%9A"><span class="toc-text">说说ConcurrentHashMap：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9ArrayList%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">说说对ArrayList的理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说ArrayList和LinkedList有什么区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">说说List和Set的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88Null%E5%80%BC%E5%AD%98%E6%94%BE%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">关于各种集合Null值存放问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E4%B8%80%E8%BE%B9%E9%81%8D%E5%8E%86%E4%B8%80%E9%81%8D%E5%88%A0%E9%99%A4%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">List一边遍历一遍删除怎么实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-text">代码描述递归算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E5%92%8CSpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">SpringMVC和SpringBoot的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%A0%BC%E5%BC%8F%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">SpringBoot的配置文件支持哪些格式？优先级是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">SpringMVC的执行流程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%EF%BC%9A"><span class="toc-text">RabbitMQ：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">生产者和消费者是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">消息的发布订阅模式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">消息发送失败如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%9B%A0%E4%B8%BA%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E5%BC%82%E5%B8%B8%E4%BC%9A%E4%B8%80%E7%9B%B4%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E5%90%97%EF%BC%9F"><span class="toc-text">消息因为系统内部异常会一直重复发送吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%EF%BC%9F%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%B4%A2%E5%BC%95%E5%AD%98%E6%94%BE%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-text">索引怎么创建？索引有哪些？索引存放的位置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="toc-text">什么是回表查询？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95MySQL%EF%BC%88%E9%9D%9E%E6%9C%AC%E5%9C%B0%EF%BC%89%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">终端登录MySQL（非本地）的命令是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-from-from%E5%90%8E%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">select * from from后面的执行顺序是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%A6%81%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">一个多对多关系的数据表要怎么设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-5%E5%92%8C8-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">MySQL 5和8 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">MySQL的默认字符集和排序规则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#utf-8%E5%92%8Cutf-8mb4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">utf-8和utf-8mb4的区别？</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JAVA面试题"><a href="#JAVA面试题" class="headerlink" title="JAVA面试题"></a>JAVA面试题</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="java基本类型分为八大类型："><a href="#java基本类型分为八大类型：" class="headerlink" title="java基本类型分为八大类型："></a>java基本类型分为八大类型：</h3><p>整数类型：byte，short，int，long	浮点类型：float，double</p>
<p>字符类型：char	布尔类型：boolean </p>
<p>byte：1字节 8位	short：2字节 16位	int：4字节 32位	long：8字节 64位	</p>
<p>float：4字节 32位	double：8字节 64位</p>
<p>char：2字节 16位	boolean：不同jvm有不同的实现</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="说说面向对象的理解："><a href="#说说面向对象的理解：" class="headerlink" title="说说面向对象的理解："></a>说说面向对象的理解：</h3><ul>
<li>面向对象包含三大基本特征：封装，继承，多态</li>
<li>封装：将对象的状态信息隐藏在对象内部，外部不能直接访问对象内部信息，使用者通过对象提供的方法对内部的信息操作和访问，提高了代码的可维护性</li>
<li>继承：是实现代码复用的手段，通过extends实现类的继承，被继承的类叫做父类，实现继承的类叫做子类。</li>
<li>多态：多态的实现离不开继承，在程序中，将参数的数据类型设置为父类，在调用程序的时候，根据情况传入某个子类的实例，这样就实现了多态。程序会根据类型的不同，做出不同的处理反馈</li>
<li>子类可以重写父类的方法，或者实现抽象类或接口的方法</li>
</ul>
<h3 id="说说final关键字："><a href="#说说final关键字：" class="headerlink" title="说说final关键字："></a>说说final关键字：</h3><ul>
<li>final可以用来修饰变量、方法、类</li>
<li>修饰变量的时候，该变量在被初始化后不能被修改，如果是修饰引用类型则引用的地址不能改变但是值可以改变</li>
<li>修饰方法的时候，该方法不能被重写</li>
<li>修饰类的时候，该类不能被继承</li>
</ul>
<h3 id="说说static修饰符的用法："><a href="#说说static修饰符的用法：" class="headerlink" title="说说static修饰符的用法："></a>说说static修饰符的用法：</h3><ul>
<li>static是用来修饰类中的成员变量、方法、代码块、内部类</li>
<li>static修饰的变量属于静态变量，也叫类变量，属于类而不是实例，可以通过类名访问</li>
<li>修饰的方法属于静态方法，一个类中的静态方法不能访问实例变量，只能访问静态变量</li>
<li>静态代码块，可以在类加载的时候执行静态初始化操作</li>
<li>static修饰的内部类，可以访问外部类的静态成员，但是不能访问非静态成员</li>
</ul>
<h3 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h3><ul>
<li>相同点：两者都不能被实例化</li>
<li>抽象类定义的关键字是abstract class，接口的关键字是interface </li>
<li>抽象类可以有静态变量、成员变量、常量，接口只能有常量</li>
<li>抽象类可以有构造方法和普通方法。但是接口在jdk1.8之前，只能有抽象方法，之后可以有默认方法和静态方法。</li>
<li>一个类只可以继承一个抽象类，但是可以实现多个接口。一个接口也可以继承多个父接口</li>
<li>抽象方法在业务中更像一个模板，有自己的基本功能，同时提供优化补充的方式</li>
<li>接口更像一种规范和要求，定义参数和返回值，要按照接口的规范实现</li>
</ul>
<h3 id="说说hashCode-和equals-的区别-为什么重写equals-就要重写hashCode-："><a href="#说说hashCode-和equals-的区别-为什么重写equals-就要重写hashCode-：" class="headerlink" title="说说hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()："></a>说说hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()：</h3><ul>
<li>hashCode()：获取哈希码，equals()：比较两个对象是否相等。 </li>
<li>二者两个约定：如果两个对象相等,它们必须有相同的哈希码；若两个对象的哈希码相同,他们却不一定相等。也就是说,equals()比较两个对象相等时hashCode()一定相等,hashCode()相等的两个对象equqls()不一定相等。 </li>
<li>加分回答：由于hashCode()与equals()具有联动关系,equals()重写时,hashCode()进行重写,使得这两个方法始终满足相关的约定。</li>
<li>可以关联HashMap说说</li>
</ul>
<h3 id="请你说说-与equals-的区别："><a href="#请你说说-与equals-的区别：" class="headerlink" title="请你说说&#x3D;&#x3D;与equals()的区别："></a>请你说说&#x3D;&#x3D;与equals()的区别：</h3><ul>
<li>&#x3D;&#x3D;和EQUALS都是JAVA中判断两个变量是否相等的方式,如果判断的是两个基本类型的变量,并且两者都是数值类型(不一定要求数据类型完全相同),只要两个变量的值相等就会返回TRUE。</li>
<li>对于两个引用变量只有他们指向同一个引用时,&#x3D;&#x3D;才会返回TRUE。&#x3D;&#x3D;不能用于比较类型上没有父子关系的两个对象。  </li>
<li>EQUALS()方法是OBJECT类提供的一个实例方法,所以所有的引用变量都能调用EQUALS()方法来判断他是否与其他引用变量相等,但使用这个方法来判断两个引用对象是否相等的判断标准与使用&#x3D;&#x3D;运算符没有区别,它同样要求两个引用变量指向同一个对象才会返回TRUE,但如果这样的话EQUALS()方法就没有了存在的意义,所以如果我们希望自定义判断相等的标准时,可以通过重写EQUALS方法来实现。重写EQUALS()方法时,相等条件是由业务要求决定的,因此EQUALS()方法的实现是由业务要求决定的。</li>
</ul>
<h3 id="说说重载的重写的区别："><a href="#说说重载的重写的区别：" class="headerlink" title="说说重载的重写的区别："></a>说说重载的重写的区别：</h3><ul>
<li>重载是发生在同一个类中，重写是发生在子类当中</li>
<li>重载要求方法名相同，但是返回类型，参数，访问修饰符可以不同</li>
<li>重写要求方法名，返回类型，参数都相同，并且子类重写方法的访问修饰符不能大于父类，如果父类的访问修饰符为private，则子类不能重写此方法</li>
</ul>
<h3 id="说说构造方法能不能重写："><a href="#说说构造方法能不能重写：" class="headerlink" title="说说构造方法能不能重写："></a>说说构造方法能不能重写：</h3><ul>
<li>构造方法在一个类中可以有多个，多个构造器的形参列表不同，可以称作构造器重载，让java类包含了多个初始化逻辑。</li>
<li>构造方法不能被重写，因为重写要求子类和父类的方法名一样，但是不同类的类名是不同的，构造方法是需要和类同名，所以不能重写。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="说说String类-以及new和字符串直接量的区别："><a href="#说说String类-以及new和字符串直接量的区别：" class="headerlink" title="说说String类,以及new和字符串直接量的区别："></a>说说String类,以及new和字符串直接量的区别：</h3><ul>
<li>String类是java常用的API，其中有很多封装好的处理字符串的方法，比如charAt 查找索引处的字符、indexOf查询字符首次出现的位置、subString截取字符串等方法</li>
<li>String的特点有不可变性，一旦被创建其内容就无法被更改，然后对字符串的修改都会产生一个新的String对象</li>
<li>String是被final修饰的，不能被继承</li>
<li>创建字符串有两种方式：用字符串常量创建的时候，JVM会检查字符串池中是否存在相同内容的字符串，如果有则返回这个字符串的引用</li>
<li>如果使用new来创建字符串，则不会去检查字符串池，直接在堆内存创建新的String对象</li>
</ul>
<h3 id="String、StringBuilder、StringBuffer有什么区别？"><a href="#String、StringBuilder、StringBuffer有什么区别？" class="headerlink" title="String、StringBuilder、StringBuffer有什么区别？"></a>String、StringBuilder、StringBuffer有什么区别？</h3><ul>
<li>String类是不可变的，一旦创建字符串内容不能修改，所有修改的字符串会创建为新的字符串对象，这使得String在多线程的环境下是安全的</li>
<li>StringBuffer类，也是可变字符串序列，修改字符串不会创建新的对象，操作中使用了同步机制，加了锁，性能不如StringBuilder</li>
<li>StringBuilder类，可变字符序列，操作不被synchronized修饰，性能优于StringBuffer，但是线程不安全</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="说说Java的异常处理机制："><a href="#说说Java的异常处理机制：" class="headerlink" title="说说Java的异常处理机制："></a>说说Java的异常处理机制：</h3><ul>
<li>异常机制让程序具有容错性和健壮性，程序允许出现错误时，系统会生成一个Exception对象来通知程序</li>
<li>处理异常的语句由 try，catch，finally 组成，try用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally则是用于回收资源，是最后会执行的代码</li>
<li>如果程序出现异常，系统会创建一个异常类，提交给JVM，JVM寻找可以处理这个异常的catch块，交给这个块来处理，当JVM没有找到的时候，允许环境终止，java程序退出</li>
<li>java也允许程序主动抛出异常，当业务中用判断符合某项错误的条件成立的时候，可以用throw关键字向外抛出异常</li>
</ul>
<h3 id="说说java有哪些异常："><a href="#说说java有哪些异常：" class="headerlink" title="说说java有哪些异常："></a>说说java有哪些异常：</h3><ul>
<li>主要分为受检异常Checked Exception和非受检异常Unchecked Exception，还有严重错误Error</li>
<li>Checked Exception 受检异常是表示程序允许时可能遇到的异常，需要通过try catch显式处理，通常表示外部环境的问题，比如：IOExpection、SQLException、ClassNotFoundException</li>
<li>非受检异常，也叫runtimeException，是程序逻辑错误引起的，比如：NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException</li>
<li>Error严重错误，这些错误不需要捕获和处理，比如：OutOfMemoryError，StackoverflowError</li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="说说java-IO流分为几种？"><a href="#说说java-IO流分为几种？" class="headerlink" title="说说java IO流分为几种？"></a>说说java IO流分为几种？</h3><ul>
<li>Java IO是Java提供处理数据输入和输出的API</li>
<li>根据数据流方向：<ul>
<li>输入流 Input Stream、Writer：从源 比如文件、网络中读取到程序</li>
<li>输出流 Output Stream、Reader：将数据从程序中写出到外部文件，比如文件、网络、控制台</li>
<li>以上分别是用于读取 和写入的抽象类，其他的具体流类都是它们的实现类</li>
</ul>
</li>
<li>根据处理数据单位：<ul>
<li>字节流 Byte Streams：以字节为单位读写数据，主要用于处理二进制数据，比如音频、图像文件等 ：Input Stream、Output Stream</li>
<li>字符流 Character Streams：以字符为单位读写数据，主要处理文本数据：Writer、Reader</li>
</ul>
</li>
<li>在 Java I&#x2F;O 中，<code>FileInputStream</code>、<code>ByteArrayInputStream</code>、<code>BufferedInputStream</code> 是字节流，用于处理二进制数据。</li>
<li><code>FileInputStream</code> 用于从文件中读取字节数据，<code>ByteArrayInputStream</code> 从内存中的字节数组读取数据，而 <code>BufferedInputStream</code> 提供缓冲功能以提高读取效率。</li>
<li>字符流包括 <code>FileReader</code>、<code>BufferedReader</code>、<code>InputStreamReader</code>，其中 <code>FileReader</code> 用于读取文本文件，<code>BufferedReader</code> 增加了按行读取的功能并提供缓冲，而 <code>InputStreamReader</code> 则将字节流转换为字符流，用于处理带有字符编码的数据源。</li>
</ul>
<p>完整回答：</p>
<p>“Java IO是Java中用于处理数据输入和输出的API。根据数据流的方向，Java IO分为输入流和输出流。输入流（如<code>InputStream</code>和<code>Reader</code>）用于从外部源读取数据到程序中，而输出流（如<code>OutputStream</code>和<code>Writer</code>）则将数据从程序写出到外部目标。</p>
<p>按处理的数据单位，Java IO分为字节流和字符流。字节流以字节为单位读写数据，主要用于处理二进制数据，比如音频或图像文件。<code>InputStream</code>和<code>OutputStream</code>是字节流的抽象类，常见的具体实现包括<code>FileInputStream</code>用于从文件中读取字节数据，<code>ByteArrayInputStream</code>用于从内存中的字节数组读取数据，而<code>BufferedInputStream</code>提供缓冲功能以提高读取效率。</p>
<p>字符流则以字符为单位读写数据，主要用于处理文本。<code>Reader</code>和<code>Writer</code>是字符流的抽象类，具体实现包括<code>FileReader</code>用于读取文本文件，<code>BufferedReader</code>增加了按行读取的功能并提供缓冲，而<code>InputStreamReader</code>则将字节流转换为字符流，便于处理带有字符编码的数据源。”</p>
<h3 id="说说BIO、NIO、AIO："><a href="#说说BIO、NIO、AIO：" class="headerlink" title="说说BIO、NIO、AIO："></a>说说BIO、NIO、AIO：</h3><ul>
<li>BIO是blocking IO，是传统的Java I&#x2F;O操作系统，基于阻塞I&#x2F;O实现。每个请求都有一个独立的线程来处理，线程会阻塞等待数据读写操作完成，简单易用，高并发下性能较差</li>
<li>NIO是非阻塞IO，用户线程发送请求后，可以做其他工作，并且通过轮询的方式不断询问内核数据，但在数据复制阶段，用户线程仍然数据阻塞状态。适合高并发环境</li>
<li>BIO和NIO都属于同步IO</li>
<li>AIO是异步IO模式，用户线程发送请求后，内核会返回一个回调函数，不包含数据，之后用户线程可以处理其他操作，当数据准备好后，内核会将数据发送给用户线程，不必向同步IO中用户线程自己去读取</li>
<li>BIO只能处理一个请求，NIO可以处理多个请求，</li>
</ul>
<h3 id="有了字节流为什么要有字符流？"><a href="#有了字节流为什么要有字符流？" class="headerlink" title="有了字节流为什么要有字符流？"></a>有了字节流为什么要有字符流？</h3><ul>
<li>字符流是JVM将字节转换得到的，这个转换过程耗时，而且不知道编码类型容易出现乱码问题</li>
<li>所以IO直接提供一个操作字符的接口，自动处理字符编码和解码，字符流支持字符集编码转换，可以增强处理多语言字符</li>
</ul>
<h3 id="说说Java中的编码问题："><a href="#说说Java中的编码问题：" class="headerlink" title="说说Java中的编码问题："></a>说说Java中的编码问题：</h3><ul>
<li>Java中常见的字符编码有iso、utf-8、gbk</li>
<li>iso是一种单字节编码，适用于英文等西欧语言，如果这个编码格式显示中文会乱码</li>
<li>utf-8是一种可变长度字符编码，用于表示Unicode字符集，兼容ASCII，可以表示世界上几乎所有的语言，</li>
<li>GBK在处理中文字符更加高效，如果是一下旧版中文系统，可以使用这个</li>
</ul>
<h3 id="说说utf-8-和utfmb4的区别："><a href="#说说utf-8-和utfmb4的区别：" class="headerlink" title="说说utf-8 和utfmb4的区别："></a>说说utf-8 和utfmb4的区别：</h3><ul>
<li>UTF-8和UTF-8MB4的主要区别在于编码范围和存储能力</li>
<li>UTF-8最多使用3个字节存储一个字符，适用于大部分普通文本</li>
<li>UTF-8MB4最多使用4个字节，能够存储所有的Unicode字符，包括表情符号和特殊符号。</li>
<li>对于需要存储表情符号或扩展字符的应用场景，UTF-8MB4是更好的选择。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="说说序列化、反序列化："><a href="#说说序列化、反序列化：" class="headerlink" title="说说序列化、反序列化："></a>说说序列化、反序列化：</h3><ul>
<li>序列化是将对象转换为字节流的过程，可以将对象存储或传输到文件或者通过网络传输</li>
<li>反序列化是将字节流还原为对象的过程</li>
<li>再Java中通过实现Serializable接口启用对象的序列化</li>
<li>通过ObjectOutputStream将对象写入到文件或其他输入流中</li>
<li>通过ObjectInputStream从文件中读取输入流读取对象，将字节流转换为对象（用强制转换 读取objectInputStream.readstream()）</li>
<li>Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来进行一些操作，比如将对象转化为 byte 数组或者将 json 串转化为对象。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="说说泛型、类型擦除："><a href="#说说泛型、类型擦除：" class="headerlink" title="说说泛型、类型擦除："></a>说说泛型、类型擦除：</h3><ul>
<li>在JDK1.5中，引入了泛型，在没有泛型之前，每次从集合中读取对象都必须进行类型转换，如果在插入对象时，类型出错，那么运行时转换处理的阶段就出错</li>
<li>在引入泛型之后，可以明确指定集合接受哪些对象类型，编译器就能知道并且自动为插入的代码进行泛化，在编译阶段如果插入类型错误的对象就会报错</li>
<li>泛型擦除，java泛型时伪泛型，因为java代码在编译阶段，所有的泛型信息都会被擦除，生成的字节码文件是不包含泛型信息的</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="说说对反射的理解："><a href="#说说对反射的理解：" class="headerlink" title="说说对反射的理解："></a>说说对反射的理解：</h3><ul>
<li>反射是在程序运行的时候动态的获取对象的属性和方法的功能叫做反射。它能够在程序运行期间，对于任意一个类都能知道它的所有方法和属性。</li>
<li>可以在不知道类具体实现的情况下创建类实例、调用方法、访问属性。</li>
<li>反射在框架、工具类库等方面由广泛的应用</li>
</ul>
<h3 id="反射在框架工具类中的应用场景："><a href="#反射在框架工具类中的应用场景：" class="headerlink" title="反射在框架工具类中的应用场景："></a>反射在框架工具类中的应用场景：</h3><ul>
<li>Spring框架中的依赖注入，通过反射，Spring容器可以在运行的时候，动态的实例化Bean，并将其注入到其他Bean中。Spring通过扫描类路径获取注解，比如：@AutoWired、@Component，然后通过反射创建对象、设置属性、调用方法</li>
<li>使用JDBC时，如果要创建数据库的连接，需要先通过反射机制，加载数据库的驱动程序</li>
<li>面向切面编程AOP的实现方案，是在程序运行时创建目标对象的代理类</li>
</ul>
<h2 id="JDK-1-8新特性"><a href="#JDK-1-8新特性" class="headerlink" title="JDK 1.8新特性"></a>JDK 1.8新特性</h2><h3 id="讲一下Java-8的新特性："><a href="#讲一下Java-8的新特性：" class="headerlink" title="讲一下Java 8的新特性："></a>讲一下Java 8的新特性：</h3><p><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。   </p>
<p>​    <strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。   </p>
<p>​    <strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。   </p>
<p>​    <strong>新工具</strong> − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。   </p>
<p>​    <strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。   </p>
<p>​    <strong>Date Time API</strong> − 加强对日期与时间的处理。   </p>
<p>​    <strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。   </p>
<p>​    <strong>Nashorn, JavaScript 引擎</strong> − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p>
<h2 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h2><h3 id="说说多线程："><a href="#说说多线程：" class="headerlink" title="说说多线程："></a>说说多线程：</h3><ul>
<li>线程是操作系统调度的最小单元，它可以让进程并发的处理多个任务</li>
<li>一个进程可以创建多个线程，各个线程共享程序的内存空间，比如代码段，多个线程可以执行相同的代码；</li>
<li>共享数据段，多个线程可以访问或修改相同的全局变量或静态变量；</li>
<li>共享堆空间，堆是动态分配内存的区域，通常分配对象的内存，多个线程可以创建、访问和修改堆中的对象；</li>
<li>每个线程拥有自己的栈空间</li>
<li>多线程的优点：减少程序响应时间，提高cpu利用率，数据共享效率高</li>
</ul>
<h3 id="说说多线程的注意点："><a href="#说说多线程的注意点：" class="headerlink" title="说说多线程的注意点："></a>说说多线程的注意点：</h3><ul>
<li>线程安全方面，多个线程同时访问共享资源时，可能导致数据不一致。可以使用synchronized或lock加锁来确保线程安全</li>
<li>频繁创建和销毁线程会浪费系统资源，使用线程池来管理线程可以重用线程，减少线程的开销</li>
</ul>
<h3 id="说说线程的创建方式："><a href="#说说线程的创建方式：" class="headerlink" title="说说线程的创建方式："></a>说说线程的创建方式：</h3><ul>
<li>创建线程有三种方式：继承thread类、实现Runable接口、实现Callable接口</li>
<li>定义Thread类的子类，重写run方法，创建这个子类的实例，调用线程对象的start（）方法来启动这个线程</li>
<li>实现Runable接口，实现接口的run（）方法，创建实现类的实例，将其作为参数来创建Thread对象，调用start（）方法来启动线程</li>
<li>实现Callable接口，重写call方法，call方法为线程的执行体，创建Callable实现类的实例，以该实例为参数，创建FutureTask对象。使用FutureTask对象作为参数，创建Thread对象启动线程，调用FutureTask对象的get（）方法，获得子线程结束的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running using Thread class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running using Runnable interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Thread result from Callable.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); <span class="comment">// 获取返回结果</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建线程分为两种：继承父类、实现接口</li>
<li>实现Runable接口和Callable接口创建线程的区别是：Runable没有返回值。但是Callable有返回值</li>
<li>采用接口方式创建线程的优点是：线程类可以继承别的其他类。</li>
<li>如果采用继承Thread类，就不可以继承其他的父类</li>
</ul>
<h3 id="说说线程的状态："><a href="#说说线程的状态：" class="headerlink" title="说说线程的状态："></a>说说线程的状态：</h3><ul>
<li>java线程在运行的生命周期中，有六个状态：</li>
<li>NEW：初始状态，线程被创建，但是没有调用start方法</li>
<li>RUNABLE：可运行状态，线程正在JVM执行，可能是等待操作系统的调度</li>
<li>BLOCKED：阻塞状态，线程正在等待获取监视器锁，当一个线程试图进入一个 <code>synchronized</code> 方法或代码块，而此时该对象的监视器锁已经被其他线程占用，这个线程就会进入阻塞状态，等待监视器锁的释放。</li>
<li>WATING：等待状态，线程正在等待其他线程的的操作来继续执行，当一个线程调用某个对象的 <code>wait()</code> 方法时，线程会释放该对象的监视器锁，并进入 WAITING 状态，直到另一个线程调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法来唤醒它。</li>
<li>TIMED_WATING：超时等待状态，在等待状态的基础上增加了超时时间，即超出时间自动返回。</li>
<li>TERMINATED：终止状态，线程已经执行完毕</li>
</ul>
<h3 id="说说wait（）和sleep（）的区别："><a href="#说说wait（）和sleep（）的区别：" class="headerlink" title="说说wait（）和sleep（）的区别："></a>说说wait（）和sleep（）的区别：</h3><ul>
<li>wait是object类的方法，而sleep是Thread类的方法</li>
<li>wait（）调用的时候会释放当前线程的锁，其他线程可以进入同步代码块或方法，而sleep（）不会释放锁，线程只是暂停执行，但是仍然持有锁</li>
<li>wait（）通常在同步块或方法中使用，目的是让当前线程等待，直到其他线程调用notify（）或notify All（）</li>
<li>sleep（）只是让线程休眠一段时间，不涉及锁和同步</li>
</ul>
<h3 id="说说怎么保证线程安全："><a href="#说说怎么保证线程安全：" class="headerlink" title="说说怎么保证线程安全："></a>说说怎么保证线程安全：</h3><ul>
<li><p>线程安全是在多线程中，线程没有按照预期执行，导致操作共享变量出现异常。在java中有多种同步方案可以使用：原子类、volatile关键字、锁</p>
</li>
<li><p>原子类：基于底层CAS，比较和替换机制，比较要更新的值是否等于预期值。<code>AtomicInteger</code>、<code>AtomicReference</code>，通过原子操作确保线程安全，避免锁的开销。</p>
</li>
<li><p>volatile关键字：适用于确保变量的可见性，但它不保证操作的原子性</p>
</li>
<li><p>使用synchronized关键字，可以在方法或代码块上使用，确保同一时间只有一个线程可以访问                 </p>
</li>
<li><p>使用Lock锁：通过lock、unlock方法所住一段代码</p>
</li>
</ul>
<h3 id="说说你了解的线程同步方式："><a href="#说说你了解的线程同步方式：" class="headerlink" title="说说你了解的线程同步方式："></a>说说你了解的线程同步方式：</h3><ul>
<li>java主要通过加锁的方式实现线程同步，锁分为两种：synchronized和Lock</li>
<li>synchronized可以加在三个位置：</li>
<li>加在普通方法上的时候，锁的是这个方法的实例对象；加在静态方法上，锁的是当前类的对象；加在代码块上时，要在synchronized后显式指定一个对象，当一个线程要进入这个代码块，必须要先获得这个对象的锁 </li>
<li>synchronized是比较早期的API，没有超时等机制</li>
<li>Lock支持的功能包括：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）</li>
</ul>
<h3 id="说说你了解的线程通信方式："><a href="#说说你了解的线程通信方式：" class="headerlink" title="说说你了解的线程通信方式："></a>说说你了解的线程通信方式：</h3><ul>
<li>包括使用wait&#x2F;notify进行简单的同步，Lock和Condition提供更灵活的控制，</li>
<li>ThreadLocal为线程提供独立的变量存储</li>
</ul>
<h3 id="说说Java中常用的锁和原理："><a href="#说说Java中常用的锁和原理：" class="headerlink" title="说说Java中常用的锁和原理："></a>说说Java中常用的锁和原理：</h3><ul>
<li>synchronized关键字和lock锁接口：</li>
<li>synchronized关键字底层用的是java对象头来存储锁信息</li>
<li>lock接口是基于AQS实现，AQS内部是一个先进先出队列实现锁的同步，同时定义了同步状态记录锁的信息</li>
</ul>
<h3 id="说说synchronized和lock的区别："><a href="#说说synchronized和lock的区别：" class="headerlink" title="说说synchronized和lock的区别："></a>说说synchronized和lock的区别：</h3><ul>
<li>synchronized是同步锁，可以修饰普通方法、静态方法、代码块</li>
<li>修饰普通方法，锁住的是实例对象；修饰静态方法时，锁住的是类对象；修饰代码块的时候，是要指定一个对象，然后锁住</li>
<li>当一个线程在使用被锁住的方法时，获取了它的锁，其他线程想要访问当前资源只能等待当前锁释放锁</li>
<li>synchronized是java的关键字，lock是接口</li>
<li>synchronized可以作用在代码块和方法上，lock只能用在代码里</li>
<li>synchronized在代码执行完毕或出现异常会自动释放锁，但是lock不会自动释放，需要在finally中释放</li>
<li>synchronized会导致线程拿不到锁一直等待，死锁。但是lock可以设置超时时间，如果在指定时间内无法获取锁，线程可以选择退出或执行其他操作</li>
<li>synchronized无法知道是否获取锁成功，但是lock可以通过tryLock判断是否加锁成功</li>
</ul>
<h3 id="说说synchronized的原理："><a href="#说说synchronized的原理：" class="headerlink" title="说说synchronized的原理："></a>说说synchronized的原理：</h3><ul>
<li>原理是通过JVM在编译生成的 monitorenter 和 monitorexit 指令来实现</li>
<li>这些指令利用Java对象头中的锁信息来管理锁的获取和释放</li>
<li>当线程进入或者退出同步代码块的时候，会自动获取和释放对象的监视器锁，从而实现线程的同步控制</li>
</ul>
<h3 id="说说你对AQS的理解："><a href="#说说你对AQS的理解：" class="headerlink" title="说说你对AQS的理解："></a>说说你对AQS的理解：</h3><ul>
<li>AQS队列同步器，用来构建锁的基本框架，Lock实现类都是基于AQS实现的</li>
<li>AQS是基于模板方法模式进行设计的，锁的实现需要继承AQS并重写指定的方法</li>
<li>AQS内部定义了一个先进先出的队列来实现线程的同步，同时还定义了同步状态来记录锁的信息</li>
</ul>
<h3 id="说说对线程池的理解："><a href="#说说对线程池的理解：" class="headerlink" title="说说对线程池的理解："></a>说说对线程池的理解：</h3><ul>
<li>线程池可以管理线程的数量，减少无节制的创建线程导致超出系统负荷。</li>
<li>可以让线程复用，大大减少创建和销毁线程所带来的开销</li>
<li>线程池管理了多个线程的生命周期，提供了任务的提交和调度机制，减少线程上下文切换的开销</li>
<li>线程池的生命周期分为五种：</li>
<li>RUNING -1：线程可以接受新任务并处理队列中的任务</li>
<li>SHUTDOWN 0：线程池不再接收新的任务，但是会继续处理队列中的任务</li>
<li>STOP 1：线程不在接受新的任务，也不再处理队列中的任务，并中断正在执行的任务</li>
<li>TIDYING 2：所有任务都终止，线程池工作的线程数都为0，即将调用terminated（）方法</li>
<li>TEMINATED 3：teminated（）方法调用完毕，线程池完全终止</li>
</ul>
<h3 id="说说volatile的用法和原理："><a href="#说说volatile的用法和原理：" class="headerlink" title="说说volatile的用法和原理："></a>说说volatile的用法和原理：</h3><ul>
<li>volatile是一个轻量级的synchronized，它可以在多线程中确保共享变量的可见性。保证一个线程修改一个共享变量的时候，另外一个线程可以读取整个修改的值</li>
<li>底层原理是通过内存屏障（Memory Barrier）来实现的，读写 <code>volatile</code> 变量时会在指令前后插入内存屏障，确保变量的可见性和有序性，但不保证原子性。常用于避免多线程中变量不一致问题，如双重检查锁定的单例模式中。</li>
</ul>
<h3 id="说说对threadlocal的理解："><a href="#说说对threadlocal的理解：" class="headerlink" title="说说对threadlocal的理解："></a>说说对threadlocal的理解：</h3><ul>
<li>ThreadLocal，线程变量，是一种为每个线程提供独立的变量副本，确保每个线程对变量的访问互不打扰，避免线程之间共享数据问题，也叫不需要同步机制了</li>
<li>提供线程变量，可以存储线程私有的状态和上下文信息，比如用户会话</li>
<li>实现原理：每个Thread对象中都有一个ThreadLocalMap对象，他是一个键值对形式的容器，可以用set、get方法存取共享变量。</li>
<li>ThreadLocal对象作为key来存取共享变量，用完之后必须remove，否则会造成内存泄漏</li>
<li>在线程池中，线程不会在任务结束后立即销毁，而是重用。若 <code>ThreadLocal</code> 未被清除，它对应的值可能无法释放，累积后导致内存泄漏。</li>
</ul>
<h3 id="说说JUC："><a href="#说说JUC：" class="headerlink" title="说说JUC："></a>说说JUC：</h3><ul>
<li>JUC是java.util.concurrent的缩写，这个包中包含了支持并发操作的各种工具：</li>
<li>原子类：底层使用CAS机制实现原子性，原子类包括：AtomicInteager 支持对int类型变量的原子操作、AtomicBoolean、AtomicLong、AtomicReference 支持对引用类型变量进行原子操作</li>
<li>Lock锁类：和synchroized类似，在此基础上增加了超时机制，响应中断机制，用于解决多线程安全问题</li>
<li>线程池：可以方便的管理线程，避免重复开线程和杀线程的消耗</li>
<li>并发容器：比如ConcurrentHashMap、CopyOnWriteArrayList，支持多线程操作的并发集合</li>
</ul>
<h3 id="java哪些地方用来CAS？"><a href="#java哪些地方用来CAS？" class="headerlink" title="java哪些地方用来CAS？"></a>java哪些地方用来CAS？</h3><ul>
<li>CAS是比较和交换的意思，使用场景有原子类、AQS、并发容器</li>
<li>实现类原子类 atomicInteager…、并发容器集合 ConcurrentHashMap、Lock的底层实现是AQS，AQS的实现是通过一个volatile的状态变量和CAS操作控制线程的访问权限保证原子性</li>
</ul>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="说说对java集合的理解："><a href="#说说对java集合的理解：" class="headerlink" title="说说对java集合的理解："></a>说说对java集合的理解：</h3><ul>
<li>java集合类主要分为两类：Collection和Map这两个接口派生而出，其中Collection接口派生出 List、Set、Queue</li>
<li>Set 中元素无序存储、元素不可重复</li>
<li>List 是有序存储，顺序为存储顺序，元素可以重复</li>
<li>Queue 是先进先出队列</li>
<li>Map 是存放键值对的 代表映射关系的集合</li>
<li>这些集合的实现类有ArrayList、LinkedList、TreeSet、HashSet、HashMap等，这些实现类都不是线程安全，但是性能好</li>
<li>线程安全的集合实现类有：Vector、HashTable、ConcurrentHashMap</li>
<li>Vector实现了List接口，是一个动态数组，所有方法都是同步的，使用了synchronized实现</li>
<li>HashTable 实现了Map接口，是基于hash表的数据结构，用于存储键值对，不允许有null键和值，所有方法也是同步的，因此是线程安全的，但是性能不好</li>
<li>HashTable、ConcurrentHashMap、TreeMap、TreeMap、EnumMap、EnumSet 不允许有null出现</li>
</ul>
<h3 id="说说线程安全的集合："><a href="#说说线程安全的集合：" class="headerlink" title="说说线程安全的集合："></a>说说线程安全的集合：</h3><ul>
<li>线程安全的集合有Vector 实现List接口，底层是动态数组、HashTable 实现Map类，底层是哈希表实现</li>
<li>利用Collection工具类，提供了synchronizedList&#x2F;Set等方法，将集合类包装从线程安全的集合类</li>
<li>使用JUC包下的并发容器，比如ConcurrentHashMap、ConcurrentLinkedQueue</li>
<li>使用写时复制的并发容器，比如 CopyOnWirteArrayList &#x2F; Set，读写时会创建一个新的副本在这个上面修改、不会受到写操作的影响</li>
</ul>
<p>vector 实现list 底层是动态数组，hashtable是加锁的hashmap 底层是hash表</p>
<p>使用object类中的synchronizedlist&#x2F;set，将线程不安全的集合加锁转换为安全的集合</p>
<p>JUC中的并发容器，concurrentHashMap、ConcurrentLinkedQueue</p>
<p>写时复制的并发容器，CopyOnWriteArrayList&#x2F;Set</p>
<h3 id="说说HashMap的底层原理："><a href="#说说HashMap的底层原理：" class="headerlink" title="说说HashMap的底层原理："></a>说说HashMap的底层原理：</h3><ul>
<li>在JDK1.8之前HahMap的底层是数组加链表、再1.8之后是数组加链表加红黑树</li>
<li>put流程是 根据哈希算法确定元素的下标位置，当向集合存入数据时，会计算传入key的hash值，通过将哈希值取绝对值再根据集合长度取余来确定元素位置</li>
<li>如果这个位置存在其他元素，则发生哈希冲突，这个新的元素会被存在当前位置的链表中，如果链表的长度超过8，就会转化为红黑树。</li>
<li>Hash不是线程安全</li>
</ul>
<h3 id="说说HashMap和HashTable的区别："><a href="#说说HashMap和HashTable的区别：" class="headerlink" title="说说HashMap和HashTable的区别："></a>说说HashMap和HashTable的区别：</h3><ul>
<li>区别在于是否线程安全，是否可以存放null值</li>
<li>Hashtable再实现Map接口的时候包装了线程安全，加入了同步机制</li>
<li>HashMap是非线程安全，所有HashTable的性能不如HashMap</li>
<li>HashTable不允许存入null，无论是key还是Value，都会异常</li>
<li>HashMap可以存放null，都可以</li>
<li>多线程下推荐使用ConcurrentHashMap，它不但保证了线程安全，也降低了锁的颗粒度，提高了并发访问的性能</li>
</ul>
<h3 id="HashMap是线程安全的吗？如果不是该如何解决？"><a href="#HashMap是线程安全的吗？如果不是该如何解决？" class="headerlink" title="HashMap是线程安全的吗？如果不是该如何解决？"></a>HashMap是线程安全的吗？如果不是该如何解决？</h3><ul>
<li>使用Hashtable、使用Collections将HashMap包装成线程安全的HashMap、使用ConcurrentHashMap,</li>
</ul>
<h3 id="说说ConcurrentHashMap："><a href="#说说ConcurrentHashMap：" class="headerlink" title="说说ConcurrentHashMap："></a>说说ConcurrentHashMap：</h3><ul>
<li>ConcurrentHashMap的底层数据结构与HashMap一样,也是采用“数组+链表+红黑树 </li>
<li>采用锁定头节点的方式降低了锁粒度,以较低的性能代价实现了线程安全。</li>
<li>实现机制：初始化数组或头节点时,ConcurrentHashMap并没有加锁,而是CAS的方式进行原子替换 </li>
<li>插入数据时会进行加锁处理,但锁定的不是整个数组,而是槽中的头节点。所以,ConcurrentHashMap中锁的粒度是槽,而不是整个数组,并发的性能很好。 </li>
<li>扩容时会进行加锁处理,锁定的仍然是头节点。并且,支持多个线程同时对数组扩容,提高并发能力。 </li>
<li>在扩容的过程中,依然可以支持查找操作。</li>
</ul>
<h3 id="说说对ArrayList的理解："><a href="#说说对ArrayList的理解：" class="headerlink" title="说说对ArrayList的理解："></a>说说对ArrayList的理解：</h3><ul>
<li>ArrayList是基于数组实现的，内部封装了一个Object[] 数组</li>
<li>通过默认构造器创建的时候，先被初始化为空数组，之后在首次添加数据的时候，将其初始化为容量为10的数组</li>
<li>也可以通过有参构造函数创建容器，通过参数显式指定数组的容量，数组会被初始化为指定容量的数组</li>
<li>如果向ArrayList数组中添加数据超出长度限制，会自动触发自动扩容，然后添加数据</li>
<li>扩容计算数组拷贝，将旧数组的数据拷贝到新数组中，新数组的长度为原来的1.5倍</li>
<li>支持缩容，但是不会自动缩容，可以调用trimToSize（）方法</li>
<li>ArrayList是有序可重复集合，提供了iterator方法</li>
</ul>
<h3 id="说说ArrayList和LinkedList有什么区别："><a href="#说说ArrayList和LinkedList有什么区别：" class="headerlink" title="说说ArrayList和LinkedList有什么区别："></a>说说ArrayList和LinkedList有什么区别：</h3><ul>
<li>ArrayList的实现是基于数组的，LinkedList的实现是基于双向链表</li>
<li>对于随机访问集合元素，ArrayList要优于Linked，ArrayList可以根据下标以复杂度为1对元素进行随机访问，而LinkedList的每个元素要都是依赖地址指针和下一个元素连接，所以查找的复杂度为N</li>
<li>对于插入和删除的操作，LinkedList要优于ArrayList，因为当元素被添加到Linked任意位置，只需要调节节点的前后引用，但是ArrayList插入操作可能要移动大量元素</li>
<li>LinkedList比Array更占内存，因为除了存储数据，还存储了两个前后引用</li>
</ul>
<h3 id="说说List和Set的区别："><a href="#说说List和Set的区别：" class="headerlink" title="说说List和Set的区别："></a>说说List和Set的区别：</h3><ul>
<li>List集合是有序存储的，可以存储重复的元素，集合内每个元素都有对应的顺序索引，默认是按照插入顺序设置索引</li>
<li>Set集合中的元素是无序存储的，不能存储重复元素，不允许包含相同的元素，会失败，add方法会返回False</li>
<li>Set虽然无序，但是也有支持排序的集合：TreeSet，TreeSet可以确保元素处于排序状态，底层是红黑树实现，如果元素实现了Comparable接口，TreeSet会使用接口的compareTo（）方法来确定元素顺序，如果在创建TreeSet的时候在参数中提供一个Comparator，TreeSet会使用这个定制排序来确定元素顺序，TreeSet内部元素不能为Null值</li>
</ul>
<h3 id="关于各种集合Null值存放问题："><a href="#关于各种集合Null值存放问题：" class="headerlink" title="关于各种集合Null值存放问题："></a>关于各种集合Null值存放问题：</h3><ul>
<li><strong>数组和链表实现的集合</strong> 通常直接存储对象，因此能够存放 <code>null</code>。</li>
<li><strong>哈希表实现的集合</strong> 允许 <code>null</code>，但通常 <code>null</code> 键只能有一个，因为哈希表使用键的哈希码来定位元素，而 <code>null</code> 键是一个特殊情况。</li>
<li><strong>红黑树和其他需要比较操作的集合</strong> 不允许 <code>null</code>，因为 <code>null</code> 无法参与元素比较。</li>
<li><strong>线程安全集合</strong> 通常为了避免 <code>null</code> 引发的潜在并发问题，选择不支持 <code>null</code>。</li>
</ul>
<h3 id="List一边遍历一遍删除怎么实现？"><a href="#List一边遍历一遍删除怎么实现？" class="headerlink" title="List一边遍历一遍删除怎么实现？"></a>List一边遍历一遍删除怎么实现？</h3><ul>
<li><p>使用Iterator提供的remove方法</p>
</li>
<li><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));
Iterator&lt;String&gt; iterator = list.iterator();

while (iterator.hasNext()) &#123;
    String element = iterator.next();
    if (&quot;b&quot;.equals(element)) &#123;
        iterator.remove();  // 使用迭代器的remove方法
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># JVM</span><br><span class="line"></span><br><span class="line">### 什么是栈？</span><br><span class="line"></span><br><span class="line">### 什么是堆？</span><br><span class="line"></span><br><span class="line">### stack和heap的区别</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line"># MySQL面试题</span><br><span class="line"></span><br><span class="line">### 说说innodb和myisam的区别：</span><br><span class="line"></span><br><span class="line">- innodb支持事务，默认支持行锁；MyISAM不支持事务，默认的锁是表锁</span><br><span class="line">- 读写性能：Innodb增删改性能更优；MyISAM查询性能更优势</span><br><span class="line"></span><br><span class="line">### 如何定位慢查询？</span><br><span class="line"></span><br><span class="line">- 开启慢查询日志，在MySQL的配置文件中设置 slow_query_log参数为1，设置慢查询日志的路径，设置慢查询的时间限制</span><br><span class="line">- 找到慢查询的SQL后，可以用EXPLAIN命令查看MySQL是怎么执行SQL语句的</span><br><span class="line"></span><br><span class="line">### 如何分析、优化不必要的列：</span><br><span class="line"></span><br><span class="line">- 用EXPLAIN命令查看，通过key和key_len查询是否命中了索引</span><br><span class="line">- 通过type查看这条sql的连接类型，是否存在全索引扫描和全盘扫描</span><br><span class="line">- 通过extra判断，是否出现回表，如果有，尝试添加索引挥着修改返回字段来修复</span><br><span class="line">- 尽量避免select *，只查询需要的列，减少数据传输量</span><br><span class="line"></span><br><span class="line">### 说说什么是索引：</span><br><span class="line"></span><br><span class="line">- 索引是帮助MySQL高效获取数据的数据结构。数据库系统还维护者特定查找算法的数据结构（B+树），这些数据结构引用数据库数据，这样就可以在数据结构上实现高级查找算法，不用扫描整张表</span><br><span class="line">- 提高数据检索成本。降低数据库io的成本</span><br><span class="line">- 通过索引列对数据进行排序，降低数据排序成本，降低cpu功耗</span><br><span class="line"></span><br><span class="line">### 说说索引的分类：</span><br><span class="line"></span><br><span class="line">- 主键索引：每个表只能有一个主键索引，通常由主键列自动生成创建，主键索引是一种唯一索引，保证数据唯一性，不允许由null值</span><br><span class="line">- 唯一索引：保证索引列的值唯一，可以有多个，允许由null值，适用于需要保证某列唯一性的场景</span><br><span class="line">- 普通索引：最常见的索引类型，用于加速查询，不强制保证列的唯一性</span><br><span class="line">- 组合索引：包含多个列的索引，用于提高联合查询的效率，列的顺序对查询性能由影响，查询时要按照索引中列的顺序使用索引</span><br><span class="line">- 全文索引：用于对文本字段进行全文搜索，使用与搜索长文本数据，如文章内容、评论</span><br><span class="line"></span><br><span class="line">### 索引的底层数据结构了解吗：</span><br><span class="line"></span><br><span class="line">- MySQL的InnoDB引擎采用了B+树的数据结构来存储索引</span><br><span class="line">- 查询的阶数更多，一个节点可以包含更多的子节点。查询路径更短，B+树是平衡树。</span><br><span class="line">- 磁盘读写代价更低，非叶子节点只存储指针，叶子节点存储数据</span><br><span class="line">- 叶子节点是一个双向链表，B+树便于扫库和区间查询</span><br><span class="line"></span><br><span class="line">### 说说B树和B+树的区别：</span><br><span class="line"></span><br><span class="line">- B树和B+树都是多路平衡查找树</span><br><span class="line">- B树中所有节点都存放数据；B+树只有叶子节点存放数据，其他节点存放key</span><br><span class="line">- B树叶子节点是独立的，B+树的叶子节点是通过链表与相邻的叶子节点连接</span><br><span class="line">- B树查找使用的二分查找，没有找到叶子节点就结束了；B+树必须从根节点查找，更稳定</span><br><span class="line"></span><br><span class="line">### 请你说说索引怎么实现的B+树,为什么选这个数据结构？</span><br><span class="line"></span><br><span class="line">- 索引本质上通过预排序和树型结构提升检索效率，MySQL 的 InnoDB 和 MyISAM 引擎都使用 B+ 树来实现索引。</span><br><span class="line">- B+ 树是一种平衡多路查找树，相比二叉查找树，它降低了树的深度，从而减少了磁盘 IO 次数。</span><br><span class="line">- B+ 树的叶子节点存放着所有数据，并通过指针连接，实现快速的范围查找。通常，B+ 树的高度在 2～4 层，查找某一键值的行记录时最多需要 2～4 次 IO。B+ 树索引包括聚集索引和辅助索引，区别在于叶子节点是否存放完整行的信息。</span><br><span class="line"></span><br><span class="line">### 什么是聚簇索引什么是非聚簇索引（二级索引）？什么是回表？</span><br><span class="line"></span><br><span class="line">- 聚簇索引（聚集索引）：数据和索引放在一块，B+树的叶子节点保存了整行数据，有且只有一个</span><br><span class="line">- 非聚簇索引（二级索引）：数据和索引分开存储，B+树的叶子节点存放对应的主键，可以有多个</span><br><span class="line">- 回表查询：通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表</span><br><span class="line">- InnoDB 采用的是聚簇索引，如果没有显式定义主键，InnoDB 会选择一个唯一的非空列作为隐式的聚簇索引；如果这样的列也不存在，InnoDB 会自动生成一个隐藏的行 ID 作为聚簇索引。这意味着数据与主键是紧密绑定的，行数据直接存储在索引的叶子节点上。</span><br><span class="line">- MyISAM 采用的是非聚簇索引，表数据存储在一个地方，而索引存储在另一个地方，索引指向数据行的物理位置。</span><br><span class="line"></span><br><span class="line">### 说说什么是覆盖查询？</span><br><span class="line"></span><br><span class="line">- 覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</span><br><span class="line">- 当使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高</span><br><span class="line">- 如果返回的列中没有创建索引，可能会触发回表查询，尽量避免使用select*</span><br><span class="line"></span><br><span class="line">### MySQL超大分页怎么处理？</span><br><span class="line"></span><br><span class="line">- 在数据量较大的时候，limit分页查询会导致性能下降，因为偏移量大，需要跳过的行数多</span><br><span class="line">- 优化方式是利用覆盖索引，用子查询获取需要的主键id，如何根据id再查找对应数据。</span><br><span class="line">- 这样MySQL只需要扫描索引不用访问实际表数据，提高查询效率</span><br><span class="line"></span><br><span class="line">### 说说事务的四大特性：</span><br><span class="line"></span><br><span class="line">- 事务时一个或多个SQL语句组成的一个执行单元，这些语句要么全部执行完毕，要么全部不执行。事物的主要作用是保证数据库操作的一致性，对于维护数据库完整性非常重要</span><br><span class="line">- 事务具有四个基本特性，简称ACID：</span><br><span class="line">  - 原子性 Atomicity：事务是不可分割的整体，要么全部执行成功，要么执行失败回滚</span><br><span class="line">  - 一致性 Consistency：事务执行前后，数据库都要保持一致性状态，比如在账户转账的时候，应该保证转账前后两个账户的总金额保持不变、</span><br><span class="line">  - 隔离性 Isolation：事物的隔离性确保了并发事务之间互不干扰，用于解决并发执行时可能的问题，比如脏读、不可重复读、幻读，事务提交之前对其他的事务不可见。</span><br><span class="line">  - MySQL提供了如 未提交、读已提交、可重复读、串行化来控制事务间的隔离程度</span><br><span class="line">  - 持久性 Durability：一旦事务提交，它对数据库的更改时永久性的，即使系统崩溃，数据库也能恢复到上一次提交的状态</span><br><span class="line"></span><br><span class="line">### 并发事务问题：</span><br><span class="line"></span><br><span class="line">- 脏读：一个事务读到另一个事务没有提交的数据</span><br><span class="line">- 不可重复读：一个事务在先后两次读取同一段数据，但是两次的数据不同（在两次读取之间，有其他事务修改并提交了数据）</span><br><span class="line">- 幻读：一个事务在条件查数据的时候，没有对应的数据行，但是在插入的时候又出现了这行数据（在两次查询中间，有其他事务插入了新的数据）</span><br><span class="line"></span><br><span class="line">### 说说事务的隔离级别：</span><br><span class="line"></span><br><span class="line">- MySQL提供四种隔离级别：读未提交、读已提交、可重复读、串行化</span><br><span class="line">- **读未提交**：这个级别，事务可以读取其他事务未提交的更改，不能解决所有的并发问题，但是性能高、安全性低。</span><br><span class="line">  - 比如：一个事务修改了数据，但是没有提交，另一个事务就会读取到未提交的数据，但是上一个事务可能会回滚，这将导致脏读</span><br><span class="line">- **读已提交**：在这个级别，事务只能读取到其他事务已经提交的更改。</span><br><span class="line">  - 只能读取提交的更改避免了脏读，但是在事务执行的过程，如果其他事务不断提交更改，就会每次读到不一样的数据，会导致不可重复读、幻读</span><br><span class="line">- **可重复读（MySQL默认）**：在这个级别下，事务会在开始时创建一个快照，在整个事务过程中，所有的读取操作都是以这个快照为基础，所以相同的查询在同一事务中会返回相同的数据</span><br><span class="line">  - 但是在某些情况下，会幻读，但是在MySQL，即使使用可重复读隔离级别，幻读通常也不会发生。这是因为事务在开始时使用快照读取数据，并且通过间隙锁防止其他事务插入新数据到查询范围内。</span><br><span class="line">- **串行化**：在这个级别下，所有事务依次顺序执行，避免并发操作带来的问题</span><br><span class="line">  - 性能最差，但是可以避免所有问题</span><br><span class="line"></span><br><span class="line">### 说说undo log和redo log的区别：</span><br><span class="line"></span><br><span class="line">- `redo log` 和 `undo log` 是 MySQL 中用于保证事务可靠性的重要日志机制</span><br><span class="line">- `redo log` 记录的是数据页的物理变化，用于保证事务的持久性，即使系统崩溃，已提交的事务也能通过 `redo log` 恢复</span><br><span class="line">- `undo log` 记录的是数据修改前的状态，主要用于支持事务回滚，保证事务的原子性和一致性。在回滚时，`undo log` 可以撤销未提交的事务，将数据恢复到原始状态。</span><br><span class="line">- 因此，`redo log` 确保了数据不丢失，而 `undo log` 确保了事务可以被正确撤销。</span><br><span class="line"></span><br><span class="line">### MySQL的主从同步是怎么实现的：</span><br><span class="line"></span><br><span class="line">-  主从同步的核心是二进制日志文件binlog，这个日志会记录所有的DDL（数据定义语言）和DML（数据操纵语言），但是不会包括数据查询语句</span><br><span class="line">-  在主库事务提交时，会把数据变更记录在二进制日志Binlog中</span><br><span class="line">-  从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay log中</span><br><span class="line">-  从库重做中继日志中的事件，将改变反映他自己的数据</span><br><span class="line"></span><br><span class="line">### 事务中的隔离性是怎么保证的？解释一下MVCC</span><br><span class="line"></span><br><span class="line">- 锁：排他锁，一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁了</span><br><span class="line">- MVCC：多版本并发控制。是用来实现数据库并发控制的一种机制，通过保存数据的多个版本来允许多个事务同时读写操作</span><br><span class="line">- 每个事务再开始时会创建一个快照，保证它在执行过程中看到的数据是一致的，即使其他事务同时修改数据，也能够有效实现数据库隔离性和一致性</span><br><span class="line"></span><br><span class="line">MVCC 是 MySQL InnoDB 存储引擎用来实现高并发环境下数据一致性的一种技术，它通过隐藏字段、`undo log`、版本链和 `ReadView` 来实现。在每一行记录中，InnoDB 会保存两个隐藏字段：`trx_id` 和 `roll_pointer`。`trx_id` 记录了最后修改该行记录的事务 ID，`roll_pointer` 则指向 `undo log`，保存了记录的旧版本数据。</span><br><span class="line"></span><br><span class="line">这些旧版本数据通过 `roll_pointer` 形成了一个版本链，类似于一个链表结构，链中每个节点对应一次数据修改。版本链确保事务能够根据需要追溯到数据的历史版本，而 `undo log` 就是支撑这个版本链的日志系统。</span><br><span class="line"></span><br><span class="line">`undo log` 记录了事务修改数据前的状态，不仅用于事务回滚，也为 MVCC 提供了多版本的数据。在数据读取时，InnoDB 会根据 `ReadView` 来决定哪些版本对当前事务可见。`ReadView` 包含当前活跃事务的列表和其他元数据，用于判断一个数据版本是否可以被当前事务读取。</span><br><span class="line"></span><br><span class="line">当事务读取的数据版本对当前事务不可见时，InnoDB 会沿着版本链，通过 `undo log` 逐个回溯，直到找到一个可见的版本。因此，MVCC 能在高并发场景下，通过提供一致性视图，实现事务的隔离性，避免加锁带来的性能问题，同时确保数据的一致性和隔离性，特别是在可重复读（Repeatable Read）隔离级别下有效避免幻读问题。</span><br><span class="line"></span><br><span class="line">### 了解分库分表吗？</span><br><span class="line"></span><br><span class="line">- 水平分库：将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题</span><br><span class="line">- 水平分表：解决单表存储的性能问题</span><br><span class="line">- 垂直分库：根据业务进行拆分，高并发下提高磁盘IO和网络连接数</span><br><span class="line">- 垂直分表，冷热数据分离，多表互不影响，比如一个文章表由基础信息和描述组成，可以将描述和主键id分出一张表</span><br><span class="line"></span><br><span class="line">### 请你说说乐观锁和悲观锁</span><br><span class="line"></span><br><span class="line">- 乐观锁总是假设最好的情况，认为数据的变动不会太频繁，通常时在表中添加一个版本号或时间戳</span><br><span class="line">- 在事务从数据库中取数据的是时候，会将版本号也取出，当事务对数据处理完毕后想要更新到表中，会取出之前版本与数据中最新的版本对比，如果v1=v2，说明在数据变动期间，没有其他事务对数据进行修改，此时允许事务对表中数据进行修改，而且修改时版本号加1，表明该数据被变动</span><br><span class="line">- 如果，v1 不等于 v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</span><br><span class="line">- 悲观锁总是假设最坏的情况，认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，所以每次在拿数据时都会上锁，这样别人想拿这个数据时会阻塞直到拿到锁。一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</span><br><span class="line">- mysql数据库的共享锁和排他锁都是悲观锁的实现。   </span><br><span class="line"></span><br><span class="line"># Spring框架面试题</span><br><span class="line"></span><br><span class="line">### 介绍一下Spring</span><br><span class="line"></span><br><span class="line">- Spring是一个轻量级的企业应用开发框架，他有众多模块，其中core模块是spring的核心模块，spring的核心功能IOC和Aop都是都是该模块提供的。</span><br><span class="line">- IOC就是控制反转的意思，他将对象的创建和管理交给IOC容器，来实现程序的解耦。IOC通过依赖注入来实现，依赖注入的概念就是说你不用创建对象，而只需要描述它如何被创建。依赖注入有set注入，构造方法注入、注解注入等方式。</span><br><span class="line">- aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。在Aop的思想下，我们可以通过不修改原来代码的前提下给系统添加功能。通常用于事务和日志管理。 </span><br><span class="line"></span><br><span class="line">### 说说对Spring Boot的理解，以及和Spring的区别？</span><br><span class="line"></span><br><span class="line">- Spring Boot是基于Spring框架的快速开发工具，使用“习惯优于配置”的理念让项目快速的运行起来。</span><br><span class="line">- Spring Boot本身不提供Spring的核心功能，而是作为Spring的脚手架框架。通过内嵌Web服务器、自动配置、简化的依赖管理和丰富的starter包，达到快速构建项目。</span><br><span class="line">- 自动配置：针对很多Spring应用程序常见的引用功能，Spring Boot都能自动提供相关的配置</span><br><span class="line">- 起步依赖：Spring Boot通过起步依赖为项目的依赖管理提供帮助。起步依赖就是特殊的Maven依赖和Gradle依赖，利用传递依赖解析，把常用的库聚合在一起，组成了几个为特定功能而定制的依赖</span><br><span class="line">- 端点监控：Spring Boot可以对正在运行的项目提供监控</span><br><span class="line"></span><br><span class="line">**Spring与Spring Boot的区别**：Spring是一个全面的应用开发框架，提供了丰富的功能和灵活性，但需要大量的手动配置。Spring Boot在此基础上进行了封装，提供了开箱即用的功能，自动化了许多配置工作，减少了开发者的工作量。简单来说，Spring关注的是如何实现各种功能，而Spring Boot则关注如何快速、便捷地启动并运行Spring应用。</span><br><span class="line"></span><br><span class="line">### 说说Spring Boot常用的注解：</span><br><span class="line"></span><br><span class="line">- Spring注解：</span><br><span class="line">  - **@Component、@Controller、@Service、@Repository：**使用在类上用于实例化Bean</span><br><span class="line">  - **@Autowired：**使用在字段上，用于根据类型依赖注入</span><br><span class="line">  - **@Scope：**用于标注Bean的作用范围</span><br><span class="line">  - **@Configuration：**用于指定当前类是一个Spring配置类，当创建容器的时候会从该类上加载注解，配置类可以包含一个或多个 `@Bean` 方法，这些方法的返回值会被Spring容器管理，作为Spring Bean。</span><br><span class="line">  - **@ComponentScan：**用于指定Spring在初始化容器时要扫描的包</span><br><span class="line">  - **@Bean：**使用在方法上，标注将该方法的返回值存储到Spring容器中</span><br><span class="line">  - **@Import：**使用这个注解导入的类会被Spring加载到ioc容器中</span><br><span class="line">  - **@Aspect、@Before、@After、@Around、@Pointcut：**用于切面编程AOP</span><br><span class="line">- SpringMVC注解：</span><br><span class="line">  - **@RequestMapping：**用于映射请求路径,可以定义在类上和方法上。用于类上,则表示类中的所有的方法都是以该地址作为父路径</span><br><span class="line">  - **@RequestBody：**注解实现接收http请求的json数据，将json转换为java对象</span><br><span class="line">  - **@RequestParam：**指定请求参数的名称</span><br><span class="line">  - **@PathViriable：**从请求路径下中获取请求参数(/user/fid&#125;)，传递给方法的形式参数</span><br><span class="line">  - **@ResponseBody：**注解实现将controller方法返回对象转化为json对象响应给客户端</span><br><span class="line">  - **@RequestHeader：**获取指定的请求头数据</span><br><span class="line">  - **@RestController：**代表 @Controller + @ResponseBody</span><br><span class="line">- Spring Boot注解：</span><br><span class="line">  - **@SpringBootConfiguration：**组合了@Configuration，实现了配置文件的功能。不仅继承了 `@Configuration` 的所有功能，还能够与Spring Boot的其他特性（如自动配置、外部化配置等）紧密结合</span><br><span class="line">  - **@EnableAutoConfiguration：**打开自动配置功能，在启动Spring应用程序上下文时进行自动配置，自动配置通常是基于项目classpath中引入的类和已定义的bean来实现的。</span><br><span class="line">  - **@Import：**@EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。 </span><br><span class="line">  - **@ComponentScan：**Spring组件扫描</span><br><span class="line">  - **@SpringBootApplication**：是由@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan组成的</span><br><span class="line"></span><br><span class="line">### Spring 如何管理 `@Controller`</span><br><span class="line"></span><br><span class="line">- 当Spring应用启动时，Spring容器会扫描类路径下的包，找到带有`@Controller`注解的类，并将它们实例化为Spring Bean，放入IoC容器中进行管理。</span><br><span class="line">- 然后，Spring MVC会根据配置将这些控制器中的方法映射到对应的HTTP请求上。</span><br><span class="line"></span><br><span class="line">### 说说单例Bean和多例Bean的区别和用途：</span><br><span class="line"></span><br><span class="line">- 在Spring框架中，Bean的作用域决定了其在应用中的生命周期和实例数量。</span><br><span class="line">- **单例Bean**（`@Singleton`）是Spring默认的作用域，它在整个Spring容器中只有一个实例。适用于无状态的服务或需要共享状态的组件，比如工具类和配置管理器。单例Bean能够提高性能，因为它避免了重复创建对象的开销，并且减少了内存消耗。然而，由于所有线程共享同一个实例，单例Bean在多线程环境中需要确保线程安全。</span><br><span class="line">- **多例Bean**（`@Scope(&quot;prototype&quot;)`）每次请求都会创建一个新的实例。这种作用域适合于那些需要保持独立状态的场景，比如用户会话信息、动态内容生成或需要与用户交互的组件。每次获取多例Bean时，都会返回一个新的对象实例，这样可以确保每个请求或操作都有一个全新的对象，避免了不同请求间的数据干扰。</span><br><span class="line">- 选择单例Bean还是多例Bean，主要取决于具体的使用场景和需求。单例Bean适合需要共享状态、希望提高性能的情况，而多例Bean适合需要独立对象、维护状态的场景。正确选择作用域能够优化资源使用，提升应用的稳定性和性能。</span><br><span class="line"></span><br><span class="line">### 说说对单例bean的理解，这是线程安全的吗？：</span><br><span class="line"></span><br><span class="line">- Spring框架用默认的单例Bean创建对象，如果Spring的Bean里面都是注入无状态的对象（可以理解为这个Bean不会保持任何客户端或请求的特定状态，并且不提供对内部状态的修改操作），那么是线程安全的。</span><br><span class="line">- 无状态的Bean包括 Service类、DAO类。</span><br><span class="line">- 如果在Bean中定义了可修改的成员变量，那么线程不安全，可以使用多例或者加锁来解决。最简单解决方法是将Bean的作用域改为“prototype”。</span><br><span class="line"></span><br><span class="line">### 说说Spring Boot的起步依赖：</span><br><span class="line"></span><br><span class="line">- starter配置，约定大于配置，spring boot将日常企业应用研发中的各种场景都抽取出来，做成一个个的starter（启动器），starter中整合了该场景下各种可能用带的依赖，用户只需要在Maven中引入starter依赖，spring boot就能自动扫描到要加载的信息并启动响应的默认配置 </span><br><span class="line"></span><br><span class="line">### 说说Spring Boot的启动流程：</span><br><span class="line"></span><br><span class="line">- 通过SpringApplication注解找到Spring Boot的入口类，通过main方法调用SpringApplication静态方法的run方法来实例化一个SpringApplication对象</span><br><span class="line">- 再调用这个对象的run方法，获取监听器的配置、打印Banner信息、创建并初始化容器</span><br><span class="line">- 监听器发送通知，这就完成了项目的初始化和启动</span><br><span class="line"></span><br><span class="line">### 说说Spring Boot的自动装配原理：</span><br><span class="line"></span><br><span class="line">- 在Spring Boot项目中，`@SpringBootApplication`是一个复合注解，封装了`@SpringBootConfiguration`、`@EnableAutoConfiguration`、和`@ComponentScan`三个注解。</span><br><span class="line">- 其中，`@EnableAutoConfiguration`是实现自动配置的关键。它通过`@Import`注解引入了配置选择器，读取项目和依赖的Jar包中的`META-INF/spring.factories`文件，这个文件中定义了自动配置类的全类名。Spring Boot会根据这些配置类中的条件注解（如`@ConditionalOnClass`）判断是否加载相应的Bean到Spring容器中，实现自动装配。</span><br><span class="line"></span><br><span class="line">### 说说对IOC的理解：</span><br><span class="line"></span><br><span class="line">- IOC是什么：IOC全称是Inversion of Controller，也就是控制反转。他的核心思想是把对象的管理权限交给了容器，如果程序如果需要使用某个对象的实例，直接从IOC容器中获取即可。这种设计的好处在于：降低了程序里面，对象与对象之间的耦合性，使得程序的整个体系结构更加灵活。</span><br><span class="line">- Bean的声明方式：Spring提供了很多方式声明Bean，比如在XML配置文件中通过&lt;bean&gt;标签、通过各种注解（@Component、@Service）、通过@Configuration配置类里面通过@Bean注解声明</span><br><span class="line">- Spring在启动的时候会去解析这些Bean，然后保存到IOC容器里面</span><br><span class="line"></span><br><span class="line">### IOC的工作流程：</span><br><span class="line"></span><br><span class="line">- **IOC容器的初始化阶段：**根据程序里定义的XML或者Bean，通过解析和加载后生成BeanDefinition，然后把BeanDefinition注册到IOC容器里面。通过注解或者XML声明的Bean都会解析为一个BeanDefinition实体，这个实体里会包含Bean的一些定义和基本属性，最后把BeanDefinition保存到一个Map集合里，从而完成IOC的初始化</span><br><span class="line">- IOC容器的作用就是对这些注册的Bean定义信息，进行处理和维护，是IOC容器控制反转的核心</span><br><span class="line">- **完成Bean初始化和依赖注入：**通过反射对没有设置懒加载的单例Bean进行初始化，完成Bean的依赖注入</span><br><span class="line">- **Bean的使用：**通过@Autowired注解，或者通过BeanFactory.getBean()，从IOC容器中获取一个指定的Bean实例。另外针对懒加载属性@Lazy（或XML中的 lazy-init属性为true），以及非单例Bean的实例化，实在每一次获取Bean对象的时候，调用Bean的实例化方法，来完成实例化的，并且SpringIOC容器不会去管理这些Bean</span><br><span class="line"></span><br><span class="line">### Bean创建管理方式有哪些？</span><br><span class="line"></span><br><span class="line">- **@Service、@Component、@Repository等注解：**</span><br><span class="line">  - 用于表示普通业务类、组件、DAO，这些类通常不需要复杂的初始化和销毁逻辑</span><br><span class="line">  - 当你在类上使用这些注解时，Spring会自动将这个类注册为Bean，并将其纳入到Spring容器的管理中。它们属于Spring的组件扫描机制的一部分，会自动检测到并实例化这些类。</span><br><span class="line">  - 对于普通的`@Service`类，如果没有明确的资源需要释放（如文件、数据库连接等），Spring不会执行任何额外的销毁逻辑，只会销毁对象的引用。</span><br><span class="line">- **@Bean注解：**</span><br><span class="line">  - 当你需要对Bean进行更精细的控制，比如在创建Bean时需要提供额外的构造参数、动态决定Bean的生成，或者条件性地创建Bean时。</span><br><span class="line">  - `@Bean`通常用于配置类中（带有`@Configuration`的类），它可以让你在方法中手动创建和返回一个Bean实例，并将其注册到Spring容器中。</span><br><span class="line">  - **自定义初始化和销毁方法：**</span><br><span class="line">    - 使用 `@PostConstruct` 和 `@PreDestroy` 注解，标记在Bean初始化和销毁时要执行的方法。</span><br><span class="line">    - 在 `@Bean` 注解中指定 `initMethod` 和 `destroyMethod` 参数，指定自定义的初始化和销毁方法。</span><br><span class="line">    - 实现 `InitializingBean` 和 `DisposableBean` 接口，分别定义 `afterPropertiesSet()` 和 `destroy()` 方法。</span><br><span class="line"></span><br><span class="line">### Bean的生命周期：</span><br><span class="line"></span><br><span class="line">- **实例化：**在Spring容器启动时，首先会根据配置（如XML配置、注解或Java配置类）扫描和加载Bean定义，并将这些定义转换为 `BeanDefinition` 对象。</span><br><span class="line">  - 随后，Spring容器通过反射机制实例化Bean对象，容器调用静态工厂或者调用已存在的Bean实例方法（实例工厂）来创建Bean实例，这个过程就是Bean的实例化阶段。在这个阶段，Bean只是一个简单的Java对象，还未进行依赖注入。</span><br><span class="line">- **依赖注入：**将Bean所需的依赖对象注入到该Bean中。依赖注入可以通过构造器、setter方法或字段注入的方式进行。如果Bean实现了 `BeanNameAware`、`BeanFactoryAware` 等Aware接口，Spring会在此阶段调用相应的接口方法，将Bean在Spring容器中的相关信息传递给Bean，例如Bean的名字或所属的BeanFactory。</span><br><span class="line">- **初始化：**在依赖注入完成后，Spring会对Bean进行初始化操作。</span><br><span class="line">  - 这个阶段可以通过几种方式进行：首先，如果Bean实现了 `InitializingBean` 接口，Spring会调用其 `afterPropertiesSet()` 方法；其次，如果Bean的方法上标注了 `@PostConstruct` 注解，Spring会执行这个方法；最后，如果在配置中通过 `@Bean` 注解指定了 `initMethod`，Spring会执行该方法。这一阶段通常用于执行一些需要在Bean使用之前完成的初始化逻辑，如资源加载、连接建立等。</span><br><span class="line">- **销毁实例：**当Spring容器关闭或Bean被销毁时，Spring会进入Bean的销毁阶段。</span><br><span class="line">  - 与初始化类似，销毁阶段也可以通过几种方式实现：首先，若Bean实现了 `DisposableBean` 接口，Spring会调用其 `destroy()` 方法；其次，Spring会执行标注有 `@PreDestroy` 注解的方法；最后，如果在配置中通过 `@Bean` 注解指定了 `destroyMethod`，Spring也会执行该方法。销毁阶段主要用于释放资源，如关闭数据库连接或停止线程池等。</span><br><span class="line"></span><br><span class="line">### 说说BeanFactory和FactoryBean的区别：</span><br><span class="line"></span><br><span class="line">- BeanFactory：是所有spring bean容器的顶级接口，是最基础的IOC容器，它为spring的容器定义了一套方法，并提供像getBean这样的方法从容器中获取指定的bean实例。它在产生bean的同时，还提供了解决bean之间的依赖注入的能力，也就是所谓的di。</span><br><span class="line">- FactoryBean：工厂bean，只是SpringIOC容器创建Bean的一种形式，它是一个接口，它的主要功能是动态去生成某一类型的bean的一个实例，也就是说 我们可以自定义一个bean并且加载到ioc容器里面，getObject是用来实现动态构建bean的一个过程。 </span><br><span class="line">- 与普通Bean不同，`FactoryBean`本身不是要创建的Bean，而是用来生成实际Bean实例的工厂。通过`FactoryBean`，可以控制Bean的创建过程，甚至可以返回不同类型的Bean实例。</span><br><span class="line"></span><br><span class="line">### 说说@Autowired和@Resource注解的区别：</span><br><span class="line"></span><br><span class="line">- @Autowied是Spring提供的注解，@Resource是JDK提供的注解。</span><br><span class="line">- @Autowied是只能按类型注入，@Resource默认按名称注入，也支持按类型注入。</span><br><span class="line">- @Autowired按类型装配依赖对象,默认情况下它要求依赖对象必须存在,如果允许null值,可以设置它required属性为false,如果我们想使用按名称装配,可以结合@Qualifier注解一起使用</span><br><span class="line"></span><br><span class="line">### 什么是AOP，对AOP的理解？</span><br><span class="line"></span><br><span class="line">- AOP是面向切面编程，用于将那些与业务无关的，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合</span><br><span class="line">- 简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加简洁。</span><br><span class="line">- AOP是面向切面编程，它是一种编程思想，它是一种通过预编译方式和运行期间动态代理的方式实现不修改源代码的情况下给程序动态添加功能的一种技术，可以降低代码的耦合度，便于管理，提高代码的可重用性。 AOP的实现方式有两种： JDK动态代理，可以在运行时创建接口的代理实例。 CGLIB动态代理：可以在运行期间创建子类的动态实例。 AOP的应用场景有：事务，日志管理等。</span><br><span class="line"></span><br><span class="line">### 项目中有没有用到AOP：</span><br><span class="line"></span><br><span class="line">- 用于记录操作日志、缓存、Spring实现的事务</span><br><span class="line">- 使用AOP中的环绕通知+切点表达式（找到记录日志的方法），通过环绕统治的参数获取请求方法的参数（类、方法、注解、请求方式），获取到这些参数后，保存到数据库</span><br><span class="line">- 详细在项目面试点</span><br><span class="line"></span><br><span class="line">### 说说 JDK 动态代理和 CGLIB 代理？</span><br><span class="line"></span><br><span class="line">- JDK 动态代理是基于接口的代理，只能代理实现了接口的类。使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑。</span><br><span class="line">- CGLIB 动态代理是基于继承的代理，可以代理没有实现接口的类。使用 CGLIB 动态代理时，Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑。</span><br><span class="line"></span><br><span class="line">### Spring中的事务是如何实现的：</span><br><span class="line"></span><br><span class="line">- 本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行目标方法之后根据执行情况提交或者回滚事务</span><br><span class="line">- ①编程式事务管理使用TransactionTemplate。 </span><br><span class="line">- ②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 </span><br><span class="line">- 声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</span><br><span class="line"></span><br><span class="line">### 说说Bean的作用域，默认作用域：</span><br><span class="line"></span><br><span class="line">- **1. Singleton（单例）**：这是Spring Bean的默认作用域。当一个Bean被声明为Singleton时，Spring容器在创建时只会实例化该Bean一次，并在整个应用上下文中共享该实例。无论有多少个调用者或依赖该Bean的类，都会引用同一个实例。单例作用域适用于无状态的Bean，例如DAO、服务类等，它们在整个应用程序生命周期中保持相同的行为。</span><br><span class="line">- **2. Prototype（原型）**：与Singleton相反，当Bean的作用域为Prototype时，每次请求该Bean时，Spring都会创建一个新的实例。这种作用域适用于那些需要在每次使用时都拥有全新状态的Bean，例如需要临时保存数据的对象。由于每次请求都会创建新实例，因此需要注意对这些Bean的资源管理和清理。</span><br><span class="line">- **3. Request**：这种作用域仅适用于Web应用程序。在Request作用域中，Bean实例在每个HTTP请求的生命周期内被创建并使用，在请求处理完毕后销毁。它适用于与单个HTTP请求关联的组件，例如处理用户请求的控制器或过滤器。</span><br><span class="line">- **4. Session**：同样适用于Web应用程序，在Session作用域中，Bean实例在每个HTTP会话（Session）期间被创建和共享。当用户会话结束时，Bean实例也会被销毁。Session作用域适用于需要保存用户会话信息的组件，例如用户购物车或用户偏好设置。</span><br><span class="line">- **5. Application**：在Servlet上下文中，Bean实例在整个Web应用程序生命周期内共享。这意味着所有请求和会话都将共享同一个实例，类似于单例作用域，但适用于Web应用程序的全局环境。</span><br><span class="line"></span><br><span class="line">### 说说对MVC的理解：</span><br><span class="line"></span><br><span class="line">- MVC是一种设计模式，在这个模式下软件被分为三层：Model模型、View视图、Controller控制器</span><br><span class="line">- 将软件分层的好处是 可  以将对象之间的耦合度降低，便于代码的维护。</span><br><span class="line">- Model封装了数据及其操作，是应用程序中处理和管理数据的核心部分。它负责与数据库或其他数据源进行交互，并执行业务逻辑。</span><br><span class="line">- View负责将模型中的数据展示给用户，它通常就是用户界面，用来呈现数据并与用户进行交互。</span><br><span class="line">- Controller作为控制器，在Model和View之间起到桥梁作用，主要负责处理用户请求并将其分发到相应的Model中进行处理，同时将Model的变化反馈给View，以便及时更新用户界面。Controller确保模型的状态与视图保持同步，从而实现用户请求的响应。</span><br><span class="line">- 在Spring MVC框架中，`DispatcherServlet`作为前端控制器接收所有请求，并通过`HandlerMapping`将请求映射到具体的`Controller`处理。`Controller`处理请求并返回视图名，`ViewResolver`则负责解析视图名并渲染最终的视图页面。这些组件协同工作，实现了Spring MVC中Model-View-Controller的架构模式。</span><br><span class="line"></span><br><span class="line">### 说说对Spring MVC的理解：</span><br><span class="line"></span><br><span class="line">- SpringMVC是Spring生态中的一个模块，是在Servlet基础上构建并且使用了MVC模式设计的一个Web框架。主要目的是为了简化传统的Servlet + JSP模式下的Web开发方式。</span><br><span class="line">- SpringMVC整个架构设计是对JavaWeb里面的MVC框架模式做了增强和扩展，主要体现在几个方面：</span><br><span class="line">  - 把传统的MVC框架里面的Controller控制器做了拆分，分成了前端控制器DispatcherServlet和后端控制器Controller。</span><br><span class="line">  - 把Model模型拆分成了业务层Service和数据访问层Repository。</span><br><span class="line">  - 在视图层，可以支持不同的视图，比如Freemark、velocity、JSP、Thymeleaf ...</span><br><span class="line"></span><br><span class="line">### 说说SpringMVC的执行流程：</span><br><span class="line"></span><br><span class="line">- 用户提交的Http请求提交给前端控制器(dispatcher)之后,前端控制器调用处理器映射器(HandlerMapper)来解析用户提交的路径， 处理器映射器处理好之后会返回一个处理器的信息给前端控制器， 前端控制器再将处理器的信息发送给处理器适配器(HandlerAdaper)，处理器适配器通过前端控制器提交的处理器的信息去找到相应的处理器(Handler)并执行， 执行成功后返回一个ModelAndView的对象给处理器适配器，处理器适配器返回给前端控制器， 前端控制器会请求视图解析器(ViewResolver)，对ModelAndView对象对视图处理，视图解析器根据View的信息匹配到对象的视图，并将其返回给前端控制器 前端控制器获取到具体的视图后，将存储在Model中的数据对视图进行渲染，生成最终的视图， 视图将结果显示到浏览器</span><br><span class="line">- 用户点击某个请求路径,发起一个 HTTP request 请求,该请求会被提交到前端控制器(DispatcherServlet)； </span><br><span class="line">- 由 DispatcherServlet 请求一个或多个处理器映射器(HandlerMapping),并返回一个执行链(HandlerExecutionChain)。 </span><br><span class="line">- DispatcherServlet 将执行链返回的 Handler 信息发送给处理器适配器(HandlerAdapter)； </span><br><span class="line">- HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler(常称为 Controller)； </span><br><span class="line">- Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象(Spring MVC的底层对象,包括 Model 数据模型和 View 视图信息)； </span><br><span class="line">- HandlerAdapter 接收到 ModelAndView 对象后,将其返回给 DispatcherServlet ； </span><br><span class="line">- DispatcherServlet 接收到 ModelAndView 对象后,会请求视图解析器(ViewResolver)对视图进行解析； </span><br><span class="line">- ViewResolver 根据 View 信息匹配到相应的视图结果,并返回给 DispatcherServlet； </span><br><span class="line">- DispatcherServlet 接收到具体的 View 视图后,进行视图渲染,将 Model 中的模型数据填充到 View 视图中的 request 域,生成最终的 View(视图)； </span><br><span class="line">- 视图负责将结果显示到浏览器(客户端)。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Redis面试题</span><br><span class="line"></span><br><span class="line">![image-20240830172259770](img/image-20240830172259770-17256064772591.png)</span><br><span class="line"></span><br><span class="line">## Redis使用场景</span><br><span class="line"></span><br><span class="line">### 在项目中有用到Redis吗？（结合项目）</span><br><span class="line"></span><br><span class="line">- 缓存（穿透、击穿、雪崩）、双写一致、持久化、数据过期策略、数据淘汰策略</span><br><span class="line"></span><br><span class="line">### 说说对Redis的理解：</span><br><span class="line"></span><br><span class="line">- Redis是一款基于键值对的NoSQL数据库，Redis中拥有string(字符串)，hash(哈希)、list(列表)、set（集合）等多种数据结构，redis将数据写进内存的性能很快。</span><br><span class="line">- 不仅如此，如遇到系统崩溃，内存中的数据不会丢失；</span><br><span class="line">- redis访问速度快、支持的数据类型丰富，很适合用来储存热点数据、  而且适用业务广，如可以运用expire命令来做限时业务，设置一个键的生存时间，到时间后redis会自动删除它，，如排行榜可以借住redis的SortedSet进行热点数据的排序，还有分页查询，模糊查询，点赞等。</span><br><span class="line"></span><br><span class="line">### 说说Redis的数据类型：</span><br><span class="line"></span><br><span class="line">-  String：String是Redis中最基本的数据类型，可以存储任何数据，包括二进制数据、序列化的数据、JSON化的对象甚至是图片。 </span><br><span class="line">-  List：List是字符串列表，按照插入的顺序排序，元素可以重复，你可以添加一个元素到列表的头部或者尾部，底层是一个链表结构。</span><br><span class="line">-  Set：Set是一个无序不重复的集合。 </span><br><span class="line">-  Hash：Hash是String类型的filed和value的集合，适合用于存储对象。</span><br><span class="line">-  Zset：Zset和set一样也是String类型元素的集合，且不允许有重复的元素，但不同的是Zset的每个元素都会关联一个分数，分数可以重复，Redis通过分数来为集合汇总的成员进行从小到大的排序。</span><br><span class="line">-  四种特殊数据类型：</span><br><span class="line">   - bitmap 位图 适用于高效存储和操作二进制数据。</span><br><span class="line">   - hyperloglog 用于估算大规模数据集合的基数，内存效率高。</span><br><span class="line">   - geo 用于存储和查询地理位置信息，支持距离计算和范围查找。</span><br><span class="line">   - stream 支持流式数据的处理和消息队列功能，适合处理实时数据和日志。</span><br><span class="line"></span><br><span class="line">### 如果发生缓存穿透，如何解决？</span><br><span class="line"></span><br><span class="line">- **缓存穿透：**查询一个不存在的数据，MySQL查询不到数据不会直接写入缓存，就会导致每次请求都会去查询数据库。如果这种查询非常频繁，就会给数据库造成很大的压力。</span><br><span class="line"></span><br><span class="line">- **解决方法1：**直接缓存空数据，将查不到的数据设置为空，存入缓存 &#123;key:1,value:null&#125;。</span><br><span class="line">  - 优点：简单</span><br><span class="line">  - 缺点：用空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</span><br><span class="line">    - 缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。</span><br><span class="line">- **解决方法2：**布隆过滤器</span><br><span class="line">  - 在存储和缓存之间，加一个布隆过滤器。</span><br><span class="line">  - 布隆过滤器会在数据加载初始化的时候，将数据库中所有有效键加载到过滤器中。</span><br><span class="line">  - 通过将键值进行多次哈希，得到键值在位图中的几个位置，将这些位置改为1。</span><br><span class="line">  - 查询数据的时候，使用相同的哈希函数获取hash值，判断对应位置是否为1，可以快速判断某个键是否存在数据库。（在数据库更新数据的时候，同步将布隆过滤器更新）</span><br><span class="line">  - 如果布隆过滤器判断该键不存在，则直接返回“数据不存在”响应</span><br><span class="line">  - 如果布隆过滤器判断该键可能存在，则查询缓存；如果缓存中也没有，再去查询数据库，并将结果写入缓存。</span><br><span class="line">  - 优点：内存占用少，没有多余的key</span><br><span class="line">  - 缺点：实现复杂，存在误判率</span><br><span class="line"></span><br><span class="line">### 如果发生缓存击穿，如何解决？</span><br><span class="line"></span><br><span class="line">- **缓存击穿：**当一个热点的Key（数据）设置了过期时间，当这个Key过期的时候，恰好这个时间点堆这个Key有大量的并发请求过来，这些并发请求可能会瞬间把数据库压垮。</span><br><span class="line">- **解决方法1：** 不设置超时时间</span><br><span class="line">- **解决方法2 互斥锁：**</span><br><span class="line">  - 使用互斥锁来控制并发访问，当某个缓存未命中时，只有一个请求线程会获取锁，进入数据库进行数据查询。其他线程会被阻塞，直到该线程完成数据库查询并更新缓存。</span><br><span class="line">  - 这样，其他线程就可以直接读取到更新后的缓存数据，避免同时访问数据库。</span><br><span class="line">  - 强一致，性能差</span><br><span class="line">- **解决方法3 逻辑过期：**</span><br><span class="line">  - 给缓存数据加上一个逻辑过期时间字段（expire），当新增数据到缓存时，直接维护这个字段。</span><br><span class="line">  - 流程：比如线程1查询缓存，发现逻辑时间过期。线程1获取互斥锁，来进行缓存重建，这个过程只需要一个线程即可。线程1会开启一个新的异步线程来更新Redis数据，写入缓存，重置逻辑过期时间，最后释放互斥锁。在这个重建过程中，线程1直接返回过期数据，不会阻塞。</span><br><span class="line">  - 高可用，性能优，不能保证数据一致</span><br><span class="line"></span><br><span class="line">### 如果发生缓存穿雪崩，如何解决？</span><br><span class="line"></span><br><span class="line">- **缓存雪崩：**是指在同一时段大量的缓存Key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</span><br><span class="line">- **解决方法：**</span><br><span class="line">  - 给不同的Key的过期时间添加随机值，这样每个缓存过期时间的重复率就会降低</span><br><span class="line">  - 利用Redis集群提高服务的可用性，比如哨兵模式、集群模式</span><br><span class="line">  - 给缓存业务添加降级限流策略，比如在Nginx中设置，在缓存失效或者后端服务不可用的时候，系统返回预定义的数据或者页面</span><br><span class="line">  - 给业务添加多级缓存，比如Guava或Caffeine。使用本地缓存和分布式缓存结合降低数据库的压力</span><br><span class="line"></span><br><span class="line">**降级限流策略可以解决上述所有问题，是保底回答**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Redis作为缓存，MySQL的数据如何与Redis进行同步？（双写一致性）</span><br><span class="line"></span><br><span class="line">- 坏方法：</span><br><span class="line">  - 先写MySQL，再写Redis</span><br><span class="line">  - 先写Redis，再写MySQL</span><br><span class="line">    - 多线程更新数据时候会导致数据和缓存不一致</span><br><span class="line">  - 先删除Redis，再写MySQL</span><br><span class="line">    - 在多线程更新数据时，线程会回写旧的MySQL数据到缓存</span><br><span class="line"></span><br><span class="line">- **好的同步方法有：**</span><br><span class="line">  - 缓存双删：先删除Redis，再写入MySQL，再删除Redis</span><br><span class="line">    - 可以再请求最后一次删除前，等待500ms</span><br><span class="line">    - 或者使用消息队列异步串行化删除，删除请求加入消息队列</span><br><span class="line">  - **先写MySQL，再删除Redis（项目使用的这个）**</span><br><span class="line">    - 在多线程更新数据时，对于第一次多线程查询的时候，可能出现查到的缓存和数据库不一致。</span><br><span class="line">    - 但是只存在这一次不一致，对于不是强一致性要求的业务可以容忍。</span><br><span class="line">    - 当请求进行第二次查询，由于Redis数据被删除，没有命中，会重新查数据库，回写到缓存</span><br><span class="line">    - 在技术派项目中，比如将文章标签存入缓存。要修改文章标签时，直接将标签在MySQL中修改，在删除对应的Redis，这个方法要添加事务，如果MySQL更新错误或者缓存删除失败，都要回滚操作</span><br><span class="line"></span><br><span class="line">### 说说Redis的持久化策略：</span><br><span class="line"></span><br><span class="line">- **RDB**：RDB 通过生成内存数据的快照并将其保存到磁盘上实现持久化。可以手动触发快照，也可以通过配置定期自动生成。RDB 的优点是对 Redis 的性能影响较小，因为它在指定的间隔时间内执行一次快照，适合不需要频繁写操作的场景。缺点是可能会在 Redis 意外宕机时丢失最近一次快照后的数据，因为它不能实时持久化。</span><br><span class="line">- **AOF**：AOF 通过将每次写操作以日志的方式追加到文件中，实现更高的数据安全性。AOF 可以通过三种策略进行持久化：每次写操作后同步、每秒同步、或操作系统控制的同步方式。AOF 的优点是能更精确地恢复数据，最大限度减少数据丢失，但缺点是日志文件会随操作增多而增大，可能需要定期重写以减少文件大小并提升性能。</span><br><span class="line">- 在生产环境中，Redis 通常会结合使用 RDB 和 AOF。RDB 提供定时备份，确保在灾难恢复时能够快速加载大量数据，而 AOF 提供更实时的数据保护，避免频繁的写入操作导致丢失大量数据。这种组合方式可以在性能和数据持久化之间取得更好的平衡。</span><br><span class="line"></span><br><span class="line">### 说说Redis的数据过期策略：</span><br><span class="line"></span><br><span class="line">- Redis对数据设置数据的有效时间,数据过期以后,就需要将数据从内存中删除掉。可以按照不同的规则进行删除,这种删除规则就被称之为数据的删除策略(数据过期策略)。</span><br><span class="line">  - **惰性删除：**在设置完Key过期时间之后，不去进行处理，当需要该Key的时候，再检查是否过期，如果过期，将整个Key删除，否则返回整个Key</span><br><span class="line">    - 优点：对CPU友好，指挥再使用Key的时候进行检查，这种策略避免了主动检查过期键的开销</span><br><span class="line">    - 缺点：对内存不友好，可能导致大量过期数据占用内存，直到被访问时才会被删除</span><br><span class="line">  - **定期删除：**每隔一段时间，就对Key进行检查，删除里面过期的Key（从一定数量的数据库中取出一定数量的随机Key，并删除其中过期的Key）</span><br><span class="line">    - 该策略通过在后台以低频率扫描键来删除过期数据，在惰性删除和定时删除之间取得平衡，既避免了定时删除带来的性能开销，也防止过期数据长期占用内存。</span><br><span class="line">  - Redis的过期删除策略：惰性删除和定期删除配合使用</span><br><span class="line"></span><br><span class="line">### 如果缓存过多，内存占满了怎么办？（数据淘汰策略）</span><br><span class="line"></span><br><span class="line">- 数据淘汰策略：当Redis中的内存不够时，此时项Redis中添加新的Key，Redis会按照一些规则将内存中的数据删除掉。</span><br><span class="line">- 当 Redis 缓存数据过多导致内存占满时，Redis 提供了多种数据淘汰策略来解决。常见的策略包括：**noeviction**（内存不足时拒绝写入新数据）、**volatile-lru**（从设置了过期时间的键中淘汰最少使用的键）、**allkeys-lru**（从所有键中淘汰最少使用的键）、**volatile-ttl**（淘汰即将过期的键）、**allkeys-random**（随机淘汰任意键）和 **volatile-random**（从设置了过期时间的键中随机淘汰）。这些策略可以根据不同的业务需求选择，以在内存压力下保证系统的稳定性和性能。</span><br><span class="line">- Redis默认是不删除如何数据，内存不足直接报错</span><br><span class="line"></span><br><span class="line">### 说说Redis的主从同步机制：</span><br><span class="line"></span><br><span class="line">- Redis 的主从同步机制用于保证主节点和从节点的数据一致性。当从节点启动时，会向主节点发送同步请求，主节点会生成一个 RDB 快照并发送给从节点，同时在生成快照的过程中，主节点还会将新的写操作通过缓冲区记录下来。快照传输完成后，从节点将其加载到内存中，之后主节点会将缓冲区中的增量数据发送给从节点，从节点应用这些操作以保持同步。</span><br><span class="line">- 在正常运行过程中，主节点会将所有写操作通过**命令传播**的方式发送给从节点，实现实时同步。若主从断开连接，重连时只需要同步断开期间的增量数据，而不必重新同步整个数据集，这样可以提高效率并减少开销。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 技术派项目面试点</span><br><span class="line"></span><br><span class="line">###  使用 AOP + TraceID  AOP + TraceID 记录接口访问日志，实现任务追踪和监控：</span><br><span class="line"></span><br><span class="line">- 在项目中，我们使用AOP（面向切面编程）来实现接口访问日志的记录和追踪，主要是为了在分布式系统和微服务架构中有效地监控和分析每个请求的执行路径。AOP的使用在这个过程中起到了核心作用，通过定义切面拦截所有需要记录日志的方法调用，实现了日志的自动化处理和上下文管理。</span><br><span class="line">- 具体来说，我们创建了一个AOP切面类`MdcAspect`，用于拦截所有标注了特定注解`@MdcDot`的方法或类。这个注解应用在需要日志记录的地方，例如控制器方法中。在方法执行前，切面会自动执行一段逻辑来生成一个唯一的Trace ID。这是通过自定义的Trace ID生成器实现的，生成的Trace ID可以包含丰富的上下文信息，如IP地址、时间戳、进程号等。然后，这个Trace ID被添加到MDC（Mapped Diagnostic Context）中，这是一个用于多线程环境下存储线程特定诊断信息的机制。</span><br><span class="line">- 切面在方法执行之前还会将业务代码（bizCode）等信息添加到MDC中，确保这些信息在日志中完整记录。通过`@Around`通知类型的使用，切面能够在目标方法执行前后进行逻辑的插入和操作。在方法执行期间，切面通过`ProceedingJoinPoint`对象执行实际的方法调用并获取返回结果。在方法执行结束后，切面会自动记录方法的执行时间，并将其以INFO级别的日志输出，方便监控和分析。</span><br><span class="line">- 此外，切面还负责在方法执行完毕后清理MDC中的Trace ID和业务代码，防止这些上下文信息在后续请求处理中被错误复用。这种通过AOP实现的日志记录方式非常灵活和高效，它将日志记录逻辑从业务代码中分离出来，避免了代码的重复和耦合，使系统的可维护性和可扩展性得到了极大的提升。在实现过程中，我们只需在需要的地方使用`@MdcDot`注解，AOP切面就会自动处理日志的记录和上下文的管理，这极大简化了日志记录的实现方式，并增强了系统的可观察性和问题排查能力。</span><br><span class="line"></span><br><span class="line">### 如何实现Redis的高可用，说说哨兵模式、集群模式</span><br><span class="line"></span><br><span class="line">- 为了减轻数据库访问的压力，把热点数据存储于内存中而不是从后方数据库中读取。但是在大型网络应用中，单个redis很难保证数据量的访问于存储，所以可以搭建redis集群，保证数据的分撒储存与数据的一致性，实现redis的高可用。 </span><br><span class="line">- 1、主从模式：一个master主机与多个slave从机，主节点负责写操作，从节点负责读操作。 优点：读写分离，主节点的数据会自动复制给从节点，分担主节点的压力 缺点：一旦主节点宕机，会导致部分数据未实现同步；主节点宕机与从节点都需要进行重启； </span><br><span class="line">- 2、哨兵模式：本身也是主从模式，添加了哨兵功能，可以对主节点进行观察，一旦主节点挂机就进行投票在从机中选取一个新的主机。 优点：主机可以自组切换，增加了系统的健壮性与高可用性 缺点：在选取期间无法确定主从，无法工作。 </span><br><span class="line">  - Redis 哨兵负责监控多个 Redis 实例（主从结构），当主节点宕机时，哨兵会自动选举一个从节点作为新的主节点，并更新客户端的连接信息。哨兵还负责监控主从节点的健康状态，自动进行主从切换，保证高可用性。优点是架构简单，适合小规模高可用场景；缺点是单机性能有限，数据分片能力不足。</span><br><span class="line">- 3、集群模式：实现的是数据的分布式存储，数据存储于不同的节点上，所以集群模式实现的是一种去中心化控制。在每个小集群中实现的也是主从模式，从节点只会拉取主节点的备份数据，不会参与数据的存取操作。当主节点宕机，就会启动从节点。</span><br><span class="line">  - Redis 集群通过数据分片（sharding）将数据分布在多个主节点上，每个主节点都有对应的从节点。当某个主节点发生故障时，其从节点可以自动接管数据处理，保证集群的可用性和扩展性。集群模式支持数据自动分区和水平扩展，适合处理大规模数据和高并发的场景。缺点是配置较复杂，需要对网络分区有较好的容错处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设计模式</span><br><span class="line"></span><br><span class="line">### 对设计模式了解吗？</span><br><span class="line"></span><br><span class="line">- 常用的设计模式有单例模式，工厂模式，代理模式，适配器模式等。其中java中的bean就是单例模式的体现，spring中的javabean Factory用来创建对象的实例，是工厂模式的体现；spring中aop面向切面变成，是代理模式的体现；适配器模式在springMVC中有涉及。 </span><br><span class="line">- 是的，我对设计模式有一定了解。设计模式是针对特定问题的常见解决方案，能够提升代码的可维护性、复用性和扩展性。在实际开发中，我接触过几种常用的设计模式，比如**单例模式**，用于确保类在程序运行期间只有一个实例；**工厂模式**，用于解耦对象的创建过程；还有**代理模式**，可以为对象提供额外的功能而不改变其接口。此外，我还了解像**观察者模式**、**策略模式**等，能帮助解决具体的设计问题。虽然我还在学习更复杂的模式，但我意识到设计模式在构建灵活、高效的系统中非常重要，并希望在实际项目中更多地应用这些模式。</span><br><span class="line"></span><br><span class="line">### 说说单例模式，手写实现单例模式：</span><br><span class="line"></span><br><span class="line">- **单例模式（Singleton Pattern）** 是一种设计模式，目的是确保某个类在整个程序运行期间仅有一个实例，并提供全局访问点。这种模式常用于需要全局共享的资源，如日志记录器、数据库连接池、配置管理器等。</span><br><span class="line"></span><br><span class="line">- 单例模式有多种实现方式，最常用的是懒汉式、饿汉式</span><br><span class="line"></span><br><span class="line">  - **懒汉式：**这种方式在需要的时候才创建实例，但在多线程环境下存在问题。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public static class Singleton&#123;</span><br><span class="line">        private static Singleton instance;</span><br><span class="line">        </span><br><span class="line">        private Singleton() &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        public static getInstance() &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

- **饿汉式：**这种方式在类加载时就创建实例，线程安全，但可能会造成资源浪费。

- ```java
  public class Singleton &#123;
      private static final Singleton instance = new Singleton();  // 类加载时创建实例
  
      // 私有构造函数
      private Singleton() &#123;&#125;
  
      // 提供全局访问点
      public static Singleton getInstance() &#123;
          return instance;
      &#125;
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 说说工厂模式：</span><br><span class="line"></span><br><span class="line">- **工厂模式：**一种创建型设计模式，它通过定义一个接口或抽象类来创建对象，而不是在代码中直接实例化对象。工厂模式将对象的创建逻辑与使用逻辑分离，增强代码的灵活性和可维护性。</span><br><span class="line"></span><br><span class="line">- 不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。</span><br><span class="line"></span><br><span class="line">- 分为简单工厂、工厂方法、抽象工厂模式 </span><br><span class="line"></span><br><span class="line">  - 简单工厂：提供一个统一的工厂类来创造对象,应用场景：需要创建的对象较少。客户端不关心对象的创建过程 </span><br><span class="line">  - 工厂方法：针对不同的对象提供不同的工厂，应用场景： 客户端不需要知道它所创建的对象的类。 客户端可以通过子类来指定创建对应的对象。 </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># RabbitMQ面试题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 面试经验</span><br><span class="line"></span><br><span class="line">## 飞博智慧面经</span><br><span class="line"></span><br><span class="line">### Java的基本数据类型有哪些？</span><br><span class="line"></span><br><span class="line">- 整数型：byte 1B 8b，short 2B 16b，int 4B 32b，long 8B 64b</span><br><span class="line">- 字符型：char 2B 16b</span><br><span class="line">- 浮点型：float 4B 32b，double 8B 64b</span><br><span class="line">- 布尔型：boolean 视JVM而定</span><br><span class="line"></span><br><span class="line">### stack和heap的区别？</span><br><span class="line"></span><br><span class="line">- **栈**（Stack）用于存储局部变量和方法调用相关的数据。每个线程都有自己独立的栈空间，栈中的数据包括方法参数、局部变量、返回值等。当方法被调用时，系统会在栈中为该方法分配内存来存储这些数据，方法执行完毕后，内存会自动释放。</span><br><span class="line">  - 栈的内存分配由系统自动管理，速度非常快。由于栈的空间是有限的，因此它更适合存储小规模数据，通常是基本数据类型和方法执行过程中短期存活的数据。</span><br><span class="line">- **堆**（Heap）用于存储所有的对象实例和数组。堆内存是线程共享的，所有线程都可以访问堆中的对象。开发者通过`new`关键字在堆中创建对象，而这些对象的内存分配和释放则由Java虚拟机的垃圾回收机制来管理。</span><br><span class="line">  - 由于对象的生命周期可能较长，垃圾回收会不定期地回收不再使用的对象。堆的内存空间通常比栈大，但由于堆中的对象需要通过指针进行访问，速度相对较慢。</span><br><span class="line"></span><br><span class="line">### ==、equals的区别？</span><br><span class="line"></span><br><span class="line">- ==是java中的比较运算符，用于比较两个对象的引用地址是否相同。</span><br><span class="line">- equals是对象object类的方法，所有对象内部都有，用于比较两个对象内容是否相同。</span><br><span class="line">- 如果==用于比较基本类型数值，只要两个变量的值相等就会返回true</span><br><span class="line">- ==对于两个引用变量的时候，只有这两个变量指向同一个对象，才会返回true</span><br><span class="line">- equals是object的实例方法，所以所有引用变量都可以调用equals来判断是否相等。</span><br><span class="line">- 如果equals没有被重写，功能和==一样，都需要两个引用变量指向同一个地址才会判断相等。</span><br><span class="line">- 如果我们希望自定义判断相等的标准时,可以通过重写EQUALS方法来实现。重写EQUALS()方法时,相等条件是由业务要求决定的,因此EQUALS()方法的实现是由业务要求决定的。</span><br><span class="line"></span><br><span class="line">### 线程池是什么，有什么作用？</span><br><span class="line"></span><br><span class="line">- 线程池是管理和复用线程的机制，通过预先创建一组线程，避免频繁创建或销毁线程的开销</span><br><span class="line">- 通过复用线程，减少创建和销毁线程的开销</span><br><span class="line">- 可以限制同时运行的线程数量，防止系统因创建过多线程而导致资源耗尽</span><br><span class="line">- 线程池可以自动管理和调度线程任务，开发者不需要手动处理线程的创建和销毁，减少线程上下文切换的开销。</span><br><span class="line">- 线程池通常通过`ExecutorService`接口来实现，最常用的是`ThreadPoolExecutor`类。Java提供了`Executors`工厂类，可以方便地创建不同类型的线程池。</span><br><span class="line">- ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="line">- executor.submit(new Task(i));</span><br><span class="line">-  executor.shutdown();</span><br><span class="line">- 线程池的生命周期分为五种：</span><br><span class="line">- RUNING -1：线程可以接受新任务并处理队列中的任务</span><br><span class="line">- SHUTDOWN 0：线程池不再接收新的任务，但是会继续处理队列中的任务</span><br><span class="line">- STOP 1：线程不在接受新的任务，也不再处理队列中的任务，并中断正在执行的任务</span><br><span class="line">- TIDYING 2：所有任务都终止，线程池工作的线程数都为0，即将调用terminated（）方法</span><br><span class="line">- TEMINATED 3：teminated（）方法调用完毕，线程池完全终止</span><br><span class="line"></span><br><span class="line">### 介绍数据结构：数组、链表、二叉树、哈希</span><br><span class="line"></span><br><span class="line">- **数组**：数组是一种线性数据结构，它使用一块连续的内存来存储相同类型的元素。数组的优势在于可以通过索引快速访问任意位置的元素，时间复杂度为 O(1)。但是，数组的大小在创建时固定，插入和删除元素需要移动其他元素，时间复杂度为 O(n)。</span><br><span class="line"></span><br><span class="line">  **链表**：链表是一种动态数据结构，由一系列节点组成，每个节点包含数据和一个指向下一个节点的指针。链表相比数组的优势是插入和删除操作较快，时间复杂度为 O(1)，但访问任意位置的元素需要遍历链表，时间复杂度为 O(n)。常见的链表有单向链表、双向链表和循环链表。</span><br><span class="line"></span><br><span class="line">  **二叉树**：二叉树是一种树形结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树常用于快速查找和排序，特别是二叉搜索树（BST），它的特点是左子树的所有节点值小于根节点，右子树的所有节点值大于根节点。平均情况下，查找、插入和删除的时间复杂度为 O(log n)，但在退化为链表的情况下，复杂度会变为 O(n)。</span><br><span class="line"></span><br><span class="line">  **哈希表**：哈希表是一种通过哈希函数将键映射到值的数据结构。哈希表的优势在于它可以在平均 O(1) 时间内完成插入、删除和查找操作，但在哈希冲突较多的情况下，性能可能下降到 O(n)。常见的冲突解决方法包括链地址法和开放地址法。哈希表非常适合快速查找、缓存等场景。</span><br><span class="line"></span><br><span class="line">### list、set、map的应用场景和特点</span><br><span class="line"></span><br><span class="line">- 日志、标签、需要用键来查找的数据，比如用户消息表</span><br><span class="line"></span><br><span class="line">### 了解的设计模式及其应用场景</span><br><span class="line"></span><br><span class="line">- 单例模式：确保一个对象类只有一个实例，并且只提供一个全局访问点</span><br><span class="line">- 实现方式有饿汉式和懒汉式：</span><br><span class="line">  - 饿汉式在项目在类初始化的时候就创建一个实例对象，</span><br><span class="line">  - 懒汉式只在第一次使用的时候创建实例对象，</span><br><span class="line">  - 应用场景：日志管理 确保全局只有一个日志实例、数据库连接池 用于管理数据库连接的唯一实例、线程池管理、缓存管理</span><br><span class="line">- 工厂模式：隐藏复杂对象的创建，工厂模式可以将对象的创建封装在工厂类中，使得调用者不必了解对象创建的细节，当系统需要动态的选择创建对象实例，可以通过工厂类将对象的创建和使用解耦。</span><br><span class="line">  - 应用场景：消息发送MessageFactory，根据文档类型生成文档处理类、对象序列化 SerializerFactory，根据不同序列化需求创建不同的序列化工具、数据库访问 ConnectionFactory，工具不同的数据库类型创建相应的数据库连接</span><br><span class="line"></span><br><span class="line">### 画图解释left、right、inner join的区别</span><br><span class="line"></span><br><span class="line">### 如何理解http是无连接的？</span><br><span class="line"></span><br><span class="line">- http协议是无连接的，意味着每一次请求和响应都是独立的，服务器不会保存状态信息。</span><br><span class="line">- 这就意味着每个请求都要携带足够的信息来让服务器理解客户端的请求，可以使用cookie和session机制来维护状态信息。</span><br><span class="line">- 在实际开发中可以在Http请求头中添加cookie来传递客户端状态信息</span><br><span class="line"></span><br><span class="line">### session的作用原理？</span><br><span class="line"></span><br><span class="line">- Session的工作原理是通过在服务器保存用户的状态信息，以便在用户发送请求时识别用户身份和保存用户数据</span><br><span class="line">- 在用户第一次访问时，服务器会生成一个唯一的SessionId，并且将ID存储在Cookie中。用户每次发送请求都会在请求头中携带这个sessionID，服务器通过这个ID来获取用户的状态信息</span><br><span class="line"></span><br><span class="line">### MySQL的事务隔离级别及其特性</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">### OSI七层模型及其协议</span><br><span class="line"></span><br><span class="line">- 物理层：光纤、以太网的电缆标准</span><br><span class="line">- 数据链路层：以太网、MAC地址</span><br><span class="line">- 网络层：ipv4、ipv6</span><br><span class="line">- 传输层：tcp、udp</span><br><span class="line">- 会话层：NETBOIS、RPC</span><br><span class="line">- 表示层：SSL、ASCII编码、图片格式</span><br><span class="line">- 应用层：Http、ftp、DNS</span><br><span class="line"></span><br><span class="line">### 代码描述冒泡排序</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public int[] bubbleSort(int[] arr) &#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i ++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n - i - 1; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + 1];</span><br><span class="line">                    arr[j + 1] = temp;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="代码描述递归算法"><a href="#代码描述递归算法" class="headerlink" title="代码描述递归算法"></a>代码描述递归算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算n的阶乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//通过计算右边界加上距离中点的距离计算mid</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SpringMVC和SpringBoot的区别？"><a href="#SpringMVC和SpringBoot的区别？" class="headerlink" title="SpringMVC和SpringBoot的区别？"></a>SpringMVC和SpringBoot的区别？</h3><h3 id="SpringBoot的配置文件支持哪些格式？优先级是什么？"><a href="#SpringBoot的配置文件支持哪些格式？优先级是什么？" class="headerlink" title="SpringBoot的配置文件支持哪些格式？优先级是什么？"></a>SpringBoot的配置文件支持哪些格式？优先级是什么？</h3><ul>
<li><p>SpringBoot的配置文件支持properties、yaml、yml等格式。优先级是由高到低依次为：命令行参数 &gt; java:comp&#x2F;env环境变量 &gt; servlet参数 &gt; servlet上下文参数 &gt; properties属性文件 &gt; yaml配置文件 &gt; yml配置文件。</p>
</li>
<li><p>在 Spring Boot 中，配置文件支持多种格式，如 <code>properties</code>、<code>yaml</code>、<code>yml</code>，并且不同配置源有不同的优先级。下面解释一下优先级从高到低的顺序及其含义：</p>
<ol>
<li><p><strong>命令行参数</strong>：</p>
<ul>
<li>优先级最高，可以在运行应用时通过命令行传递参数，如 <code>--server.port=8080</code>。这些参数会覆盖所有其他来源的配置。</li>
</ul>
</li>
<li><p><strong><code>java:comp/env</code> 环境变量</strong>：</p>
<ul>
<li>这是 Java 规范定义的 JNDI 环境变量，通常在应用服务器中使用。优先级仅次于命令行参数。</li>
</ul>
</li>
<li><p><strong><code>servlet</code> 参数</strong>：</p>
<ul>
<li>在 <code>web.xml</code> 中配置的 servlet 初始化参数。它们的优先级也较高，用于控制 servlet 的初始化和运行。</li>
</ul>
</li>
<li><p><strong><code>servlet</code> 上下文参数</strong>：</p>
<ul>
<li>这些是在 <code>web.xml</code> 中定义的全局上下文参数，作用于整个 Web 应用上下文，覆盖程度更广泛。</li>
</ul>
</li>
<li><p><strong><code>properties</code> 属性文件</strong>：</p>
<ul>
<li><code>application.properties</code> 是 Spring Boot 默认支持的配置格式之一。该文件可以位于 classpath 中，优先级高于 YAML 文件，但低于命令行参数或 servlet 参数。</li>
</ul>
</li>
<li><p><strong><code>yaml</code> 配置文件</strong>：</p>
<ul>
<li><code>yaml</code> 和 <code>yml</code> 是 Spring Boot 支持的另一种格式，主要用于复杂结构的数据配置（如数组、嵌套对象等）。在优先级上，它们低于 <code>properties</code> 文件。</li>
</ul>
</li>
<li><p><strong><code>yml</code> 配置文件</strong>：</p>
<ul>
<li>与 <code>yaml</code> 文件格式相同，只是文件后缀不同。优先级与 <code>yaml</code> 相同，并且通常会被放在 <code>properties</code> 文件的后面加载。</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Spring Boot 的配置机制遵循<strong>优先级覆盖原则</strong>，即优先级高的配置会覆盖优先级低的配置。因此，通过命令行传递的参数优先级最高，文件配置如 <code>properties</code> 和 <code>yaml</code> 则在优先级中靠后。</p>
</li>
</ul>
<h3 id="SpringMVC的执行流程？"><a href="#SpringMVC的执行流程？" class="headerlink" title="SpringMVC的执行流程？"></a>SpringMVC的执行流程？</h3><p>SpringCloud相关：</p>
<ol>
<li>nacos自动装配原理</li>
<li>网关如何配置跨域</li>
</ol>
<h2 id="RabbitMQ："><a href="#RabbitMQ：" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h2><h3 id="生产者和消费者是什么？"><a href="#生产者和消费者是什么？" class="headerlink" title="生产者和消费者是什么？"></a>生产者和消费者是什么？</h3><p><strong>生产者和消费者</strong> 是消息队列模型中的两个重要角色：</p>
<ul>
<li><strong>生产者（Producer）</strong>：负责将消息发送到消息队列。通常，生产者生成一些数据（任务、事件等），并将这些数据放入消息队列，等待消费者来处理。</li>
<li><strong>消费者（Consumer）</strong>：从消息队列中获取消息并进行处理。消费者接收消息后执行相应的操作，如更新数据库、发送通知等。</li>
</ul>
<p>这种模式的主要优点是<strong>解耦</strong>了生产者和消费者，生产者只负责生成数据，消费者只负责处理数据，两者之间不需要直接交互。</p>
<ul>
<li>生产者和消费者是指在并发编程中的一种经典的设计模式，用于解决生产者和消费者之间的同步问题。生产者负责生产数据并放入共享的缓冲区中，而消费者则负责从缓冲区中取出数据进行消费。生产者和消费者之间通过共享的缓冲区进行通信和协作，其中生产者和消费者都是并发执行的线程。</li>
</ul>
<h3 id="消息的发布订阅模式有哪些？"><a href="#消息的发布订阅模式有哪些？" class="headerlink" title="消息的发布订阅模式有哪些？"></a>消息的发布订阅模式有哪些？</h3><ul>
<li>主题&#x2F;订阅模式是最常见的一种发布订阅模式，其中消息被发送到一个主题，然后所有订阅了这个主题的消费者都会接收到消息。</li>
<li>管道&#x2F;过滤器模式是通过管道来过滤消息，只有符合条件的消息才会被传递给订阅者。</li>
<li>数据中心&#x2F;数据发布-订阅模式是一种更为复杂的模式，其中数据中心会发布各种数据，而订阅者可以选择订阅他们感兴趣的数据。</li>
</ul>
<h3 id="消息发送失败如何处理？"><a href="#消息发送失败如何处理？" class="headerlink" title="消息发送失败如何处理？"></a>消息发送失败如何处理？</h3><ul>
<li>重试发送：可以通过设置重试机制，当消息发送失败后，延迟一段时间后再次尝试发送消息，可以多次尝试发送，直到发送成功为止。 </li>
<li>消息持久化：将消息持久化到数据库或消息队列中，当消息发送失败时，可以从持久化存储中重新读取消息并尝试发送。</li>
<li>错误日志记录：记录发送失败的消息及失败原因到日志中，方便后续查找问题并进行排查。</li>
</ul>
<h3 id="消息因为系统内部异常会一直重复发送吗？"><a href="#消息因为系统内部异常会一直重复发送吗？" class="headerlink" title="消息因为系统内部异常会一直重复发送吗？"></a>消息因为系统内部异常会一直重复发送吗？</h3><ul>
<li>消息因为系统内部异常会一直重复发送的情况取决于消息传递的机制以及系统的设计。</li>
<li>在一些消息队列系统中，会有消息重试机制，当消息发送失败时会进行重试，但通常会有重试次数限制，避免无限重试导致系统负载过大。</li>
</ul>
<p>MySQL相关：</p>
<ol>
<li><h3 id="索引怎么创建？索引有哪些？索引存放的位置？"><a href="#索引怎么创建？索引有哪些？索引存放的位置？" class="headerlink" title="索引怎么创建？索引有哪些？索引存放的位置？"></a>索引怎么创建？索引有哪些？索引存放的位置？</h3><ul>
<li>在关系数据库中，索引是一种特殊的数据结构，用于提高数据检索的速度。创建索引可以通过在表的字段上使用CREATE INDEX语句来实现。常见的索引类型包括B树索引、哈希索引、全文索引等。索引通常存放在磁盘上，可以提高数据的检索速度。</li>
</ul>
</li>
<li><h3 id="什么是回表查询？"><a href="#什么是回表查询？" class="headerlink" title="什么是回表查询？"></a>什么是回表查询？</h3></li>
<li><h3 id="终端登录MySQL（非本地）的命令是什么？"><a href="#终端登录MySQL（非本地）的命令是什么？" class="headerlink" title="终端登录MySQL（非本地）的命令是什么？"></a>终端登录MySQL（非本地）的命令是什么？</h3><ul>
<li><pre><code>mysql -h &lt;hostname&gt; -u &lt;username&gt; -p
</code></pre>
</li>
</ul>
</li>
<li><h3 id="select-from-from后面的执行顺序是什么"><a href="#select-from-from后面的执行顺序是什么" class="headerlink" title="select * from from后面的执行顺序是什么"></a>select * from from后面的执行顺序是什么</h3><ul>
<li><strong><code>FROM</code> 子句</strong>：首先执行 <code>FROM</code> 子句，从数据库中检索表或视图的数据。这是查询的起点，确定了查询将操作的数据源。</li>
<li><strong><code>JOIN</code> 操作</strong>：如果查询中包含 <code>JOIN</code> 子句，这些 <code>JOIN</code> 操作会在 <code>FROM</code> 子句后进行。<code>JOIN</code> 用于合并来自不同表的数据。<code>JOIN</code> 的执行顺序可能会受到 <code>JOIN</code> 类型（如 INNER JOIN、LEFT JOIN 等）的影响。</li>
<li><strong><code>WHERE</code> 子句</strong>：在数据源和 <code>JOIN</code> 操作确定之后，<code>WHERE</code> 子句会被执行，用于筛选符合条件的记录。</li>
<li><strong><code>GROUP BY</code> 子句</strong>：在 <code>WHERE</code> 筛选后，<code>GROUP BY</code> 子句将数据分组。它按指定的列对记录进行分组，以便于进行聚合计算。</li>
<li><strong><code>HAVING</code> 子句</strong>：<code>HAVING</code> 子句对 <code>GROUP BY</code> 结果进行筛选，通常用于过滤分组后的结果。</li>
<li><strong><code>SELECT</code> 子句</strong>：<code>SELECT</code> 子句在所有其他操作之后执行，用于从结果集中选择所需的列或计算结果。</li>
<li><strong><code>ORDER BY</code> 子句</strong>：<code>ORDER BY</code> 子句用于对最终结果集进行排序。排序在选择数据之后进行。</li>
<li><strong><code>LIMIT</code> 子句</strong>（或 <code>TOP</code>）：<code>LIMIT</code> 子句用于限制结果集的数量，通常在排序后执行，以限制最终返回的记录数。</li>
</ul>
</li>
<li><h3 id="一个多对多关系的数据表要怎么设计？"><a href="#一个多对多关系的数据表要怎么设计？" class="headerlink" title="一个多对多关系的数据表要怎么设计？"></a>一个多对多关系的数据表要怎么设计？</h3><ul>
<li>为了设计一个多对多关系的数据表，我们需要使用一个中间表（也称为连接表或关联表）来连接两个实体表。这个中间表包含两个外键，分别指向两个实体表的主键，从而实现多对多的关系。</li>
</ul>
</li>
<li><h3 id="MySQL-5和8-的区别？"><a href="#MySQL-5和8-的区别？" class="headerlink" title="MySQL 5和8 的区别？"></a>MySQL 5和8 的区别？</h3><ul>
<li>MySQL 8 相比 MySQL 5 有了显著的改进，特别是在性能、功能和安全性方面。首先，MySQL 8 提升了并发处理能力，优化了多核处理和持久化性能，支持资源组的分配，显著提高了读写性能。其次，MySQL 8 引入了新的数据类型、窗口函数和公共表表达式（CTE）等现代 SQL 特性，扩展了查询和数据处理的灵活性。此外，MySQL 8 提供了更强的安全机制，如更完善的用户管理、默认加密和更加细致的权限控制，使系统更安全可控。</li>
</ul>
</li>
<li><h3 id="MySQL的默认字符集和排序规则是什么？"><a href="#MySQL的默认字符集和排序规则是什么？" class="headerlink" title="MySQL的默认字符集和排序规则是什么？"></a>MySQL的默认字符集和排序规则是什么？</h3><ul>
<li>默认字符集改为 <code>utf8mb4</code>，它支持更多的 Unicode 字符，包括表情符号等，而默认排序规则为 <code>utf8mb4_general_ci</code></li>
</ul>
</li>
<li><h3 id="utf-8和utf-8mb4的区别？"><a href="#utf-8和utf-8mb4的区别？" class="headerlink" title="utf-8和utf-8mb4的区别？"></a>utf-8和utf-8mb4的区别？</h3><ul>
<li>UTF-8 和 UTF-8mb4 的主要区别在于字符集的范围。<strong>UTF-8</strong> 是一种广泛使用的字符编码，能够编码 Unicode 中的基本多语言字符集，使用 1 到 3 字节来编码字符，但它不支持某些特殊字符，如表情符号等四字节字符。<strong>UTF-8mb4</strong> 则是 UTF-8 的扩展，使用最多 4 个字节来编码字符，能够支持 Unicode 的所有字符，包括表情符号和其他超出 BMP（Basic Multilingual Plane）范围的字符。因此，如果需要处理包含特殊符号或表情符号的内容，<strong>UTF-8mb4</strong> 是更合适的选择。</li>
</ul>
</li>
</ol>
<p>终端连接Redis的命令？</p>
<ol>
<li>&#96;Redis-cli -h <host> -p <port> -a <password></li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论。 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
